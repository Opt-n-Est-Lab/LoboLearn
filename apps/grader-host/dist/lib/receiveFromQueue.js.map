{"version":3,"file":"receiveFromQueue.js","sourceRoot":"","sources":["../../src/lib/receiveFromQueue.ts"],"names":[],"mappings":"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","sourcesContent":["import { setTimeout as sleep } from 'node:timers/promises';\n\nimport {\n  ChangeMessageVisibilityCommand,\n  DeleteMessageCommand,\n  ReceiveMessageCommand,\n  type SQSClient,\n} from '@aws-sdk/client-sqs';\nimport { z } from 'zod';\n\nimport * as Sentry from '@prairielearn/sentry';\n\nimport { config } from './config.js';\nimport globalLogger from './logger.js';\n\nconst GradingJobMessageSchema = z.object({\n  /** The unique ID for this job. */\n  jobId: z.string(),\n  /** The Docker image that the grading job will be executed in. */\n  image: z.string(),\n  /** The entrypoint for the container. If null, uses the default entrypoint for the image. */\n  entrypoint: z.string().nullable(),\n  /** The number of seconds after which the grading job will time out. */\n  timeout: z.number(),\n  /** Whether or not the container should have internet access. */\n  enableNetworking: z.boolean(),\n  /** Environment variables for the container. */\n  environment: z.record(z.string()),\n  /** The AWS S3 bucket containing this job's files. */\n  s3Bucket: z.string(),\n  /** The root key for the job's files. */\n  s3RootKey: z.string(),\n});\nexport type GradingJobMessage = z.infer<typeof GradingJobMessageSchema>;\n\nasync function changeVisibilityTimeout(\n  sqs: SQSClient,\n  queueUrl: string,\n  receiptHandle: string,\n  timeout: number,\n) {\n  await sqs.send(\n    new ChangeMessageVisibilityCommand({\n      QueueUrl: queueUrl,\n      ReceiptHandle: receiptHandle,\n      VisibilityTimeout: timeout,\n    }),\n  );\n}\n\nasync function startHeartbeat(sqs: SQSClient, queueUrl: string, receiptHandle: string) {\n  const abortController = new AbortController();\n\n  // Run the first extension immediately before we start processing the job.\n  await changeVisibilityTimeout(sqs, queueUrl, receiptHandle, config.visibilityTimeout);\n\n  // We want this process to run in the background, so we don't await it.\n  // `extendVisibilityTimeout` will handle errors.\n  // eslint-disable-next-line no-floating-promise/no-floating-promise\n  (async () => {\n    while (!abortController.signal.aborted) {\n      await sleep(config.visibilityTimeoutHeartbeatIntervalSec * 1000, null, { ref: false });\n\n      if (abortController.signal.aborted) return;\n\n      try {\n        await changeVisibilityTimeout(sqs, queueUrl, receiptHandle, config.visibilityTimeout);\n      } catch (err) {\n        globalLogger.error('Error extending visibility timeout', err);\n        Sentry.captureException(err);\n      }\n    }\n  })();\n\n  return abortController;\n}\n\nasync function receiveMessageFromQueue(sqs: SQSClient, queueUrl: string) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = await sqs.send(\n      new ReceiveMessageCommand({\n        MaxNumberOfMessages: 1,\n        QueueUrl: queueUrl,\n        WaitTimeSeconds: 20,\n      }),\n    );\n    const message = data.Messages?.[0];\n    if (!message || !message.Body) continue;\n    globalLogger.info('Received job!');\n    const parsedMessage = JSON.parse(message.Body);\n    const receiptHandle = message.ReceiptHandle as string;\n    return { parsedMessage, receiptHandle };\n  }\n}\n\nexport async function receiveFromQueue(\n  sqs: SQSClient,\n  queueUrl: string,\n  receiveCallback: (message: GradingJobMessage) => Promise<void>,\n) {\n  globalLogger.info('Waiting for next job...');\n  const { parsedMessage, receiptHandle } = await receiveMessageFromQueue(sqs, queueUrl);\n\n  const validatedMessage = GradingJobMessageSchema.parse(parsedMessage);\n\n  const heartbeatAbortController = await startHeartbeat(sqs, queueUrl, receiptHandle);\n\n  await receiveCallback(validatedMessage)\n    .finally(() => {\n      heartbeatAbortController.abort();\n    })\n    .then(\n      () => {\n        globalLogger.info(`Job ${validatedMessage.jobId} finished successfully.`);\n      },\n      (err) => {\n        globalLogger.info(`Job ${validatedMessage.jobId} errored.`);\n        throw err;\n      },\n    );\n\n  await sqs.send(\n    new DeleteMessageCommand({\n      QueueUrl: queueUrl,\n      ReceiptHandle: receiptHandle,\n    }),\n  );\n}\n"]}