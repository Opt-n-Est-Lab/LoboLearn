{"version":3,"file":"20230913181816_pl_courses_created_at.js","sourceRoot":"","sources":["../../src/batched-migrations/20230913181816_pl_courses_created_at.ts"],"names":[],"mappings":"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","sourcesContent":["import { execa } from 'execa';\nimport fs from 'fs-extra';\nimport { z } from 'zod';\n\nimport { makeBatchedMigration } from '@prairielearn/migrations';\nimport { loadSqlEquiv, queryOneRowAsync, queryOptionalRow, queryRow } from '@prairielearn/postgres';\n\nimport { DateFromISOString, IdSchema } from '../lib/db-types.js';\n\nconst sql = loadSqlEquiv(import.meta.url);\n\nasync function getEarliestCommitDateForCourse(coursePath: string | null): Promise<Date | null> {\n  if (coursePath == null || !(await fs.pathExists(coursePath))) {\n    return null;\n  }\n\n  const res = await execa('git', ['log', '--reverse', '--format=%cI', '--date=iso'], {\n    cwd: coursePath,\n  });\n\n  const lines = res.stdout.trim().split('\\n');\n  return lines.length > 0 ? new Date(lines[0]) : null;\n}\n\nasync function getEarliestJobSequenceDateForCourse(courseId: string): Promise<Date | null> {\n  const result = await queryRow(\n    sql.select_earliest_job_sequence_for_course,\n    { course_id: courseId },\n    DateFromISOString.nullable(),\n  );\n\n  return result;\n}\n\nfunction smallestDate(first: Date | null, second: Date | null): Date | null {\n  if (first == null) {\n    return second;\n  }\n  if (second == null) {\n    return first;\n  }\n  return first < second ? first : second;\n}\n\nexport default makeBatchedMigration({\n  async getParameters() {\n    const result = await queryOneRowAsync('SELECT MAX(id) as max from pl_courses;', {});\n    return {\n      min: 1n,\n      max: result.rows[0].max,\n      batchSize: 10,\n    };\n  },\n\n  async execute(start: bigint, end: bigint): Promise<void> {\n    for (let id = start; id <= end; id++) {\n      const course = await queryOptionalRow(\n        sql.select_course,\n        { course_id: id },\n        // CourseSchema isn't used to avoid problems if the schema changes in\n        // the future. Only fields that are actually used are added here.\n        z.object({\n          created_at: DateFromISOString.nullable(),\n          id: IdSchema,\n          path: z.string().nullable(),\n        }),\n      );\n\n      if (course == null || course.created_at != null) {\n        // This course does not exist, or it already has a created_at date.\n        continue;\n      }\n\n      const earliestCommitDate = await getEarliestCommitDateForCourse(course.path);\n      const earliestServerJobDate = await getEarliestJobSequenceDateForCourse(course.id);\n\n      // Take the earlier of the two values.\n      const createdAt = smallestDate(earliestCommitDate, earliestServerJobDate);\n      if (!createdAt) {\n        throw new Error(`Could not determine created_at date for course ${course.id}`);\n      }\n\n      await queryOneRowAsync(sql.update_course_created_at, {\n        course_id: id,\n        created_at: createdAt,\n      });\n    }\n  },\n});\n"]}