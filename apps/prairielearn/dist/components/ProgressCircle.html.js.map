{"version":3,"file":"ProgressCircle.html.js","sourceRoot":"","sources":["../../src/components/ProgressCircle.html.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAC;AAE1C,MAAM,UAAU,cAAc,CAAC,EAC7B,KAAK,EACL,QAAQ,EACR,SAAS,GAKV;IACC,+EAA+E;IAC/E,MAAM,2BAA2B,GAAG,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;IAEpD,wFAAwF;IACxF,IAAI,mBAAmB,GAAG,2BAA2B,GAAG,CAAC,KAAK,GAAG,QAAQ,CAAC,CAAC;IAE3E,4FAA4F;IAC5F,mBAAmB,GAAG,IAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,2BAA2B,CAAC,CAAC;IAEjF,4DAA4D;IAC5D,mBAAmB,GAAG,IAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,CAAC,CAAC,CAAC;IAEvD,MAAM,wBAAwB,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAEhE,gEAAgE;IAChE,IAAI,qBAAqB,GAAG,2BAA2B,GAAG,mBAAmB,CAAC;IAE9E,8FAA8F;IAC9F,8FAA8F;IAC9F,iEAAiE;IACjE,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,qBAAqB,EAAE,2BAA2B,CAAC,CAAC;IAErF,8DAA8D;IAC9D,gGAAgG;IAChG,iEAAiE;IACjE,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,qBAAqB,EAAE,CAAC,CAAC,CAAC;IAE3D,MAAM,0BAA0B,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAEpE,OAAO,IAAI,CAAA;;;;;aAKA,SAAS,IAAI,EAAE;;;;;;;;;;;;;;;;;0BAiBF,wBAAwB,MAAM,0BAA0B;;SAEzE,CAAC;AACV,CAAC","sourcesContent":["import { html } from '@prairielearn/html';\n\nexport function ProgressCircle({\n  value,\n  maxValue,\n  className,\n}: {\n  value: number;\n  maxValue: number;\n  className?: string;\n}) {\n  // The progress circle has radius of 8px, so its circumference is 2 * PI * 8px.\n  const progressCircleCircumference = 2 * Math.PI * 8;\n\n  // The filled portion length is proportional to the ratio of the value to the max value.\n  let filledPortionLength = progressCircleCircumference * (value / maxValue);\n\n  // Ensure that the filled portion is at most as long as the progress circle's circumference.\n  filledPortionLength = Math.min(filledPortionLength, progressCircleCircumference);\n\n  // Ensure that the filled portion has a non-negative length.\n  filledPortionLength = Math.max(filledPortionLength, 0);\n\n  const filledPortionLengthFixed = filledPortionLength.toFixed(2);\n\n  // The unfilled portion length is the rest of the circumference.\n  let unfilledPortionLength = progressCircleCircumference - filledPortionLength;\n\n  // Ensure that the unfilled portion is at most as long as the progress circle's circumference.\n  // This should not be necessary since the filledPortionLength is already constrained from 0 to\n  // progressCircleCircumference, but it's included for robustness.\n  unfilledPortionLength = Math.min(unfilledPortionLength, progressCircleCircumference);\n\n  // Ensure that the unfilled portion has a non-negative length.\n  // This should not be necessary since the completePortionLength is already constrained from 0 to\n  // progressCircleCircumference, but it's included for robustness.\n  unfilledPortionLength = Math.max(unfilledPortionLength, 0);\n\n  const unfilledPortionLengthFixed = unfilledPortionLength.toFixed(2);\n\n  return html`<svg\n    style=\"transform:rotate(-90deg)\"\n    width=\"20px\"\n    height=\"20px\"\n    viewBox=\"0 0 20 20\"\n    class=\"${className ?? ''}\"\n  >\n    <circle\n      cx=\"10px\"\n      cy=\"10px\"\n      r=\"8px\"\n      fill=\"none\"\n      stroke=\"var(--bs-gray-400)\"\n      stroke-width=\"3px\"\n    ></circle>\n    <circle\n      cx=\"10px\"\n      cy=\"10px\"\n      r=\"8px\"\n      fill=\"none\"\n      stroke=\"var(--bs-primary)\"\n      stroke-width=\"3px\"\n      stroke-dasharray=\"${filledPortionLengthFixed}px ${unfilledPortionLengthFixed}px\"\n    ></circle>\n  </svg>`;\n}\n"]}