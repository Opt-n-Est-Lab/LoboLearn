{"version":3,"file":"plans.js","sourceRoot":"","sources":["../../../../src/ee/lib/billing/plans.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\n\nimport { loadSqlEquiv, queryRow, queryRows, runInTransactionAsync } from '@prairielearn/postgres';\n\nimport {\n  type EnumPlanGrantType,\n  type Institution,\n  InstitutionSchema,\n  type PlanGrant,\n  PlanGrantSchema,\n} from '../../../lib/db-types.js';\nimport { type WithRequiredKeys } from '../../../lib/types.js';\nimport {\n  deleteCourseInstanceRequiredPlan,\n  insertCourseInstanceRequiredPlan,\n} from '../../models/course-instance-required-plans.js';\nimport { deletePlanGrant, ensurePlanGrant, updatePlanGrant } from '../../models/plan-grants.js';\n\nimport {\n  PLAN_NAMES,\n  type PlanFeatureName,\n  type PlanName,\n  getFeaturesForPlans,\n} from './plans-types.js';\n\nconst sql = loadSqlEquiv(import.meta.url);\n\nexport interface DesiredPlan {\n  plan: PlanName;\n  grantType: EnumPlanGrantType;\n}\n\ntype BasePlanGrantContext = Omit<PlanGrant, 'created_at' | 'id' | 'plan_name' | 'type'>;\ntype InstitutionPlanGrantContext = WithRequiredKeys<BasePlanGrantContext, 'institution_id'>;\ntype CourseInstancePlanGrantContext = WithRequiredKeys<\n  BasePlanGrantContext,\n  'institution_id' | 'course_instance_id'\n>;\ntype CourseInstanceUserPlanGrantContext = WithRequiredKeys<\n  BasePlanGrantContext,\n  'institution_id' | 'course_instance_id' | 'user_id'\n>;\ntype UserPlanGrantContext = WithRequiredKeys<BasePlanGrantContext, 'user_id'>;\ntype PlanGrantContext =\n  | InstitutionPlanGrantContext\n  | CourseInstancePlanGrantContext\n  | CourseInstanceUserPlanGrantContext\n  | UserPlanGrantContext;\ntype RecursivePlanGrantContext = PlanGrantContext | BasePlanGrantContext;\n\n/**\n * Returns the plan grants that apply directly to the given context. For\n * example, consider a course instance with a plan grant `foo` and a parent\n * institution with a plan grant `bar`. If we call this function with the\n * course instance's context, it will return only the `foo` plan grant.\n * If we call this function with the institution's context, it will return\n * only the `bar` plan grant.\n *\n * To get *all* plan grants that apply to a context, use\n * {@link getPlanGrantsForPartialContexts}.\n */\nexport async function getPlanGrantsForContext(context: PlanGrantContext): Promise<PlanGrant[]> {\n  return await queryRows(\n    sql.select_plan_grants_for_context,\n    {\n      institution_id: context.institution_id ?? null,\n      course_instance_id: context.course_instance_id ?? null,\n      user_id: context.user_id ?? null,\n    },\n    PlanGrantSchema,\n  );\n}\n\n/**\n * Returns the plan grants that apply to the given context, including those\n * that belong to a parent entity. For example, consider a course instance\n * with a plan grant for `foo` and a parent institution with a plan grant for\n * `bar`. If we call this function with the course instance's context, it will\n * return both the `foo` and `bar` plan grants. If we call this function with\n * the institution's context, it will return only the `bar` plan grant.\n *\n * To get only the plan grants that apply directly to a context, use\n * {@link getPlanGrantsForContext}.\n */\nexport async function getPlanGrantsForPartialContexts(\n  context: RecursivePlanGrantContext,\n): Promise<PlanGrant[]> {\n  return await queryRows(\n    sql.select_plan_grants_for_partial_contexts,\n    {\n      institution_id: context.institution_id ?? null,\n      course_instance_id: context.course_instance_id ?? null,\n      user_id: context.user_id ?? null,\n    },\n    PlanGrantSchema,\n  );\n}\n\nexport async function getPlanGrantsForCourseInstance({\n  institution_id,\n  course_instance_id,\n}: {\n  institution_id: string;\n  course_instance_id: string;\n}): Promise<PlanGrant[]> {\n  return await getPlanGrantsForContext({ institution_id, course_instance_id });\n}\n\nexport function getPlanNamesFromPlanGrants(planGrants: PlanGrant[]): PlanName[] {\n  const planNames = new Set<PlanName>();\n  planGrants.forEach((planGrant) => planNames.add(planGrant.plan_name));\n  return Array.from(planNames);\n}\n\nexport async function getRequiredPlansForCourseInstance(\n  course_instance_id: string,\n): Promise<PlanName[]> {\n  return await queryRows(\n    sql.select_required_plans_for_course_instance,\n    { course_instance_id },\n    z.enum(PLAN_NAMES),\n  );\n}\n\nexport async function updateRequiredPlansForCourseInstance(\n  course_instance_id: string,\n  plans: PlanName[],\n  authn_user_id: string,\n) {\n  await runInTransactionAsync(async () => {\n    const existingRequiredPlans = await getRequiredPlansForCourseInstance(course_instance_id);\n    const plansToAdd = plans.filter((plan) => !existingRequiredPlans.includes(plan));\n    const plansToRemove = existingRequiredPlans.filter((plan) => !plans.includes(plan));\n\n    for (const plan of plansToAdd) {\n      await insertCourseInstanceRequiredPlan(course_instance_id, plan, authn_user_id);\n    }\n\n    for (const plan of plansToRemove) {\n      await deleteCourseInstanceRequiredPlan(course_instance_id, plan, authn_user_id);\n    }\n  });\n}\n\nexport async function reconcilePlanGrantsForInstitution(\n  institution_id: string,\n  plans: DesiredPlan[],\n  authn_user_id: string,\n) {\n  await runInTransactionAsync(async () => {\n    const existingPlanGrants = await getPlanGrantsForContext({ institution_id });\n    await reconcilePlanGrants({ institution_id }, existingPlanGrants, plans, authn_user_id);\n  });\n}\n\nexport async function reconcilePlanGrantsForCourseInstance(\n  course_instance_id: string,\n  plans: DesiredPlan[],\n  authn_user_id: string,\n) {\n  await runInTransactionAsync(async () => {\n    const institution = await getInstitutionForCourseInstance(course_instance_id);\n    const existingPlanGrants = await getPlanGrantsForCourseInstance({\n      institution_id: institution.id,\n      course_instance_id,\n    });\n    await reconcilePlanGrants(\n      {\n        institution_id: institution.id,\n        course_instance_id,\n      },\n      existingPlanGrants,\n      plans,\n      authn_user_id,\n    );\n  });\n}\n\nexport async function reconcilePlanGrantsForCourseInstanceUser(\n  context: CourseInstanceUserPlanGrantContext,\n  plans: DesiredPlan[],\n  authn_user_id: string,\n) {\n  await runInTransactionAsync(async () => {\n    const existingPlanGrants = await getPlanGrantsForContext(context);\n    await reconcilePlanGrants(context, existingPlanGrants, plans, authn_user_id);\n  });\n}\n\nasync function reconcilePlanGrants(\n  context: PlanGrantContext,\n  existingPlanGrants: PlanGrant[],\n  desiredPlans: DesiredPlan[],\n  authn_user_id: string,\n) {\n  const newPlans = desiredPlans.filter(\n    (plan) => !existingPlanGrants.find((p) => p.plan_name === plan.plan),\n  );\n  const updatedPlanGrants = existingPlanGrants.map((planGrant) => ({\n    planGrant,\n    newType: desiredPlans.find((p) => p.plan === planGrant.plan_name)?.grantType,\n  }));\n  const deletedPlanGrants = existingPlanGrants.filter(\n    (plan) => !desiredPlans.find((p) => p.plan === plan.plan_name),\n  );\n\n  for (const plan of newPlans) {\n    await ensurePlanGrant({\n      plan_grant: {\n        ...context,\n        plan_name: plan.plan,\n        type: plan.grantType,\n      },\n      authn_user_id,\n    });\n  }\n\n  for (const planGrant of updatedPlanGrants) {\n    if (!planGrant.newType || planGrant.newType === planGrant.planGrant.type) {\n      continue;\n    }\n\n    await updatePlanGrant({\n      plan_grant: planGrant.planGrant,\n      type: planGrant.newType,\n      authn_user_id,\n    });\n  }\n\n  for (const planGrant of deletedPlanGrants) {\n    await deletePlanGrant({ plan_grant: planGrant, authn_user_id });\n  }\n}\n\nexport function planGrantsSatisfyRequiredPlans(planGrants: PlanGrant[], requiredPlans: PlanName[]) {\n  const planNames = getPlanNamesFromPlanGrants(planGrants);\n  return requiredPlans.every((requiredPlan) => planNames.includes(requiredPlan));\n}\n\nasync function getInstitutionForCourseInstance(course_instance_id: string): Promise<Institution> {\n  return await queryRow(\n    sql.select_institution_for_course_instance,\n    { course_instance_id },\n    InstitutionSchema,\n  );\n}\n\nfunction getPlansForPlanGrants(planGrants: PlanGrant[]): PlanName[] {\n  const plans = new Set<PlanName>();\n  for (const planGrant of planGrants) {\n    plans.add(planGrant.plan_name);\n  }\n  return Array.from(plans);\n}\n\n/**\n * Returns whether or not the given plan grants match all of the given features.\n */\nexport function planGrantsMatchFeatures(\n  planGrants: PlanGrant[],\n  features: PlanFeatureName[],\n): boolean {\n  const grantedPlans = getPlansForPlanGrants(planGrants);\n  const grantedFeatures = getFeaturesForPlans(grantedPlans);\n  return (\n    grantedFeatures.length === features.length &&\n    grantedFeatures.every((feature) => features.includes(feature))\n  );\n}\n\n/**\n * Given a list of existing plan grants and a list of required plans, returns\n * a list of plans that are required but not granted.\n */\nexport function getMissingPlanGrants(existingPlanGrants: PlanGrant[], requiredPlans: PlanName[]) {\n  const existingPlans = getPlansForPlanGrants(existingPlanGrants);\n  return requiredPlans.filter((plan) => !existingPlans.includes(plan));\n}\n"]}