{"version":3,"file":"stripe.js","sourceRoot":"","sources":["../../../../src/ee/lib/billing/stripe.ts"],"names":[],"mappings":"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","sourcesContent":["import Stripe from 'stripe';\n\nimport { cache } from '@prairielearn/cache';\nimport { loadSqlEquiv, queryAsync, runInTransactionAsync } from '@prairielearn/postgres';\n\nimport { config } from '../../../lib/config.js';\nimport { selectAndLockUserById, selectUserById } from '../../../models/user.js';\n\nimport { type PlanName } from './plans-types.js';\n\nconst sql = loadSqlEquiv(import.meta.url);\n\nexport function getStripeClient() {\n  if (!config.stripeSecretKey) {\n    throw new Error('Stripe is not configured.');\n  }\n\n  return new Stripe(config.stripeSecretKey);\n}\n\nexport async function getOrCreateStripeCustomerId(\n  user_id: string,\n  { name }: { name: string | null },\n): Promise<string> {\n  const user = await selectUserById(user_id);\n  if (user.stripe_customer_id) {\n    return user.stripe_customer_id;\n  }\n\n  const stripe = getStripeClient();\n  const customer = await stripe.customers.create({\n    name: name ?? undefined,\n    metadata: {\n      prairielearn_user_id: user_id,\n    },\n  });\n\n  // We update the user in a transaction with a lock to ensure that we only\n  // ever use one Stripe customer ID for each user. Note that we might create\n  // multiple Stripe customers for the same user, but that's acceptable, as\n  // the alternative would require locking during a network operation.\n  await runInTransactionAsync(async () => {\n    await selectAndLockUserById(user_id);\n    await queryAsync(sql.maybe_update_user_stripe_customer_id, {\n      user_id,\n      stripe_customer_id: customer.id,\n    });\n  });\n\n  const updatedUser = await selectUserById(user_id);\n\n  if (updatedUser.stripe_customer_id == null) {\n    throw new Error('Failed to update user with Stripe customer ID');\n  }\n\n  return updatedUser.stripe_customer_id;\n}\n\nfunction stripeProductCacheKey(id: string): string {\n  return `v1:stripe:product:${id}`;\n}\n\n/**\n * Gets the Stripe product with the given ID. Products are cached for up to\n * 10 minutes.\n */\nexport async function getStripeProduct(id: string): Promise<Stripe.Product> {\n  const cacheKey = stripeProductCacheKey(id);\n  let product: Stripe.Product = await cache.get(cacheKey);\n  if (!product) {\n    const stripe = getStripeClient();\n    product = await stripe.products.retrieve(id, { expand: ['default_price'] });\n    cache.set(cacheKey, product, 1000 * 60 * 10);\n  }\n  return product;\n}\n\nexport async function clearStripeProductCache(id: string) {\n  const cacheKey = stripeProductCacheKey(id);\n  await cache.del(cacheKey);\n}\n\nexport async function getDefaultPriceForStripeProduct(id: string): Promise<Stripe.Price> {\n  const product = await getStripeProduct(id);\n\n  // We instructed Stripe to expand the `default_price` field, so this should\n  // always be set and be an object. We only support products with a default\n  // price.\n  if (!product.default_price || typeof product.default_price !== 'object') {\n    throw new Error(`No default_price found for product ${id}`);\n  }\n\n  return product.default_price;\n}\n\nexport async function getPriceForPlan(plan: PlanName): Promise<Stripe.Price> {\n  const productId = config.stripeProductIds[plan];\n\n  if (!productId) {\n    throw new Error(`No product configured for plan ${plan}`);\n  }\n\n  return await getDefaultPriceForStripeProduct(productId);\n}\n\n/**\n * Fetches the prices for the given plans. The result is a map from plan name\n * to the price in cents.\n */\nexport async function getPricesForPlans(plans: PlanName[]): Promise<Record<string, number>> {\n  const prices: Record<string, number> = {};\n  for (const plan of plans) {\n    const price = await getPriceForPlan(plan);\n\n    if (\n      price.billing_scheme !== 'per_unit' ||\n      price.unit_amount == null ||\n      price.currency !== 'usd'\n    ) {\n      // We should never hit this in practice, because the prices should\n      // always be `per_unit`, which in turn should guarantee that\n      // `unit_amount` is set. We also only have logic for rendering USD\n      // prices, so we'll fail fast if we get a price in a different currency.\n      throw new Error(`Invalid unit_amount for price ${price.id}`);\n    }\n\n    prices[plan] = price.unit_amount;\n  }\n  return prices;\n}\n\nconst priceFormatter = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nexport function formatStripePrice(price: number) {\n  return priceFormatter.format(price / 100);\n}\n"]}