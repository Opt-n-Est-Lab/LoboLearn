{"version":3,"file":"executor.js","sourceRoot":"","sources":["../src/executor.ts"],"names":[],"mappings":"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","sourcesContent":["import { createInterface } from 'node:readline';\n\nimport {\n  type CodeCallerError,\n  CodeCallerNative,\n  type ErrorData,\n} from './lib/code-caller/code-caller-native.js';\nimport { type CallType } from './lib/code-caller/code-caller-shared.js';\nimport { FunctionMissingError } from './lib/code-caller/index.js';\n\ninterface ExecutorRequest {\n  type: CallType;\n  directory: string;\n  file: string;\n  fcn: string;\n  args: any[];\n  forbidden_modules: string[];\n}\n\ninterface ExecutorResults {\n  error?: string;\n  errorData?: ErrorData;\n  data?: any;\n  output?: string;\n  functionMissing?: boolean;\n  needsFullRestart: boolean;\n}\n\n/**\n * Receives a single line of input and executes the instructions contained in\n * it in the provided code caller.\n *\n * The Promise returned from this function should never reject - errors will\n * be indicated by the `error` property on the result.\n */\nasync function handleInput(line: string, codeCaller: CodeCallerNative): Promise<ExecutorResults> {\n  let request: ExecutorRequest;\n  try {\n    request = JSON.parse(line);\n  } catch (err) {\n    // We shouldn't ever get malformed JSON from the caller - but if we do,\n    // handle it gracefully.\n    return {\n      error: err.message,\n      needsFullRestart: false,\n    };\n  }\n\n  if (request.fcn === 'restart') {\n    let restartErr: Error | undefined;\n    let success: boolean | undefined;\n\n    try {\n      success = await codeCaller.restart();\n    } catch (err) {\n      restartErr = err;\n    }\n\n    return {\n      data: 'success',\n      needsFullRestart: !!restartErr || !success,\n    };\n  }\n\n  // Course will always be at `/course` in the Docker executor\n  try {\n    await codeCaller.prepareForCourse({\n      coursePath: '/course',\n      forbiddenModules: request.forbidden_modules,\n    });\n  } catch {\n    // We should never actually hit this case - but if we do, handle it so\n    // that all our bases are covered.\n    return { needsFullRestart: true };\n  }\n\n  let result: any, output: string | undefined, callErr: Error | CodeCallerError | undefined;\n  try {\n    ({ result, output } = await codeCaller.call(\n      request.type,\n      request.directory,\n      request.file,\n      request.fcn,\n      request.args,\n    ));\n  } catch (err) {\n    callErr = err;\n  }\n\n  const functionMissing = callErr instanceof FunctionMissingError;\n  return {\n    // `FunctionMissingError` shouldn't be propagated as an actual error\n    // we'll report it via `functionMissing`\n    error: callErr && !functionMissing ? callErr.message : undefined,\n    errorData: callErr && !functionMissing ? (callErr as CodeCallerError).data : undefined,\n    data: result,\n    output,\n    functionMissing,\n    needsFullRestart: false,\n  };\n}\n\nlet questionTimeoutMilliseconds = Number.parseInt(process.env.QUESTION_TIMEOUT_MILLISECONDS ?? '');\nif (Number.isNaN(questionTimeoutMilliseconds)) {\n  questionTimeoutMilliseconds = 10000;\n}\n\nlet pingTimeoutMilliseconds = Number.parseInt(process.env.PING_TIMEOUT_MILLISECONDS ?? '');\nif (Number.isNaN(pingTimeoutMilliseconds)) {\n  pingTimeoutMilliseconds = 60_000;\n}\n\nasync function prepareCodeCaller() {\n  return await CodeCallerNative.create({\n    dropPrivileges: true,\n    questionTimeoutMilliseconds,\n    pingTimeoutMilliseconds,\n    errorLogger: console.error,\n    // Currently, we'll always use the system Python.\n    // TODO: Point this to a venv that will be installed in the Docker image.\n    pythonVenvSearchPaths: [],\n  });\n}\n\n(async () => {\n  let codeCaller = await prepareCodeCaller();\n\n  // Our overall loop looks like this: read a line of input from stdin, spin\n  // off a python worker to handle it, and write the results back to stdout.\n  const rl = createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false,\n  });\n\n  // Once the readline interface closes, we can't get any more input; die\n  // immediately to allow our container to be removed.\n  rl.on('close', () => process.exit(0));\n\n  for await (const line of rl) {\n    const results = await handleInput(line, codeCaller);\n    const { needsFullRestart, ...rest } = results;\n    console.log(JSON.stringify(rest));\n    if (needsFullRestart) {\n      codeCaller.done();\n      codeCaller = await prepareCodeCaller();\n    }\n  }\n})().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n"]}