{"version":3,"file":"assessment.js","sourceRoot":"","sources":["../../src/lib/assessment.ts"],"names":[],"mappings":"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","sourcesContent":["import * as async from 'async';\nimport debugfn from 'debug';\nimport * as ejs from 'ejs';\nimport { z } from 'zod';\n\nimport * as error from '@prairielearn/error';\nimport * as sqldb from '@prairielearn/postgres';\n\nimport {\n  type Assessment,\n  type AssessmentInstance,\n  AssessmentInstanceSchema,\n  ClientFingerprintSchema,\n  CourseSchema,\n  DateFromISOString,\n  IdSchema,\n  QuestionSchema,\n  VariantSchema,\n} from './db-types.js';\nimport { gradeVariant } from './grading.js';\nimport { getGroupId } from './groups.js';\nimport * as ltiOutcomes from './ltiOutcomes.js';\nimport { createServerJob } from './server-jobs.js';\n\nconst debug = debugfn('prairielearn:assessment');\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nexport const InstanceLogSchema = z.object({\n  event_name: z.string(),\n  event_color: z.string(),\n  event_date: z.date(),\n  auth_user_uid: z.string().nullable(),\n  qid: z.string().nullable(),\n  question_id: z.string().nullable(),\n  instance_question_id: z.string().nullable(),\n  variant_id: z.string().nullable(),\n  variant_number: z.number().nullable(),\n  submission_id: z.string().nullable(),\n  data: z.record(z.any()).nullable(),\n  client_fingerprint: ClientFingerprintSchema.nullable(),\n  client_fingerprint_number: z.number().nullable(),\n  formatted_date: z.string(),\n  date_iso8601: z.string(),\n  student_question_number: z.string().nullable(),\n  instructor_question_number: z.string().nullable(),\n});\nexport type InstanceLogEntry = z.infer<typeof InstanceLogSchema>;\n\n/**\n * Check that an assessment_instance_id really belongs to the given assessment_id\n *\n * @param assessment_instance_id - The assessment instance to check.\n * @param assessment_id - The assessment it should belong to.\n * @returns Throws an error if the assessment instance doesn't belong to the assessment.\n */\nexport async function checkBelongs(\n  assessment_instance_id: string,\n  assessment_id: string,\n): Promise<void> {\n  if (\n    (await sqldb.queryOptionalRow(\n      sql.check_belongs,\n      { assessment_instance_id, assessment_id },\n      IdSchema,\n    )) == null\n  ) {\n    throw new error.HttpStatusError(403, 'access denied');\n  }\n}\n\n/**\n * Render the \"text\" property of an assessment.\n *\n * @param assessment - The assessment to render the text for.\n * @param urlPrefix - The current server urlPrefix.\n * @returns The rendered text.\n */\nexport function renderText(\n  assessment: { id: string; text: string | null },\n  urlPrefix: string,\n): string | null {\n  if (!assessment.text) return null;\n\n  const assessmentUrlPrefix = urlPrefix + '/assessment/' + assessment.id;\n\n  const context = {\n    clientFilesCourse: assessmentUrlPrefix + '/clientFilesCourse',\n    clientFilesCourseInstance: assessmentUrlPrefix + '/clientFilesCourseInstance',\n    clientFilesAssessment: assessmentUrlPrefix + '/clientFilesAssessment',\n  };\n  return ejs.render(assessment.text, context);\n}\n\n/**\n * Create a new assessment instance and all the questions in it.\n *\n * @param assessment - The assessment to create the assessment instance for.\n * @param user_id - The user who will own the new assessment instance.\n * @param authn_user_id - The current authenticated user.\n * @param mode - The mode for the new assessment instance.\n * @param time_limit_min - The time limit for the new assessment instance.\n * @param date - The date of creation for the new assessment instance.\n * @returns The ID of the new assessment instance.\n */\nexport async function makeAssessmentInstance({\n  assessment,\n  user_id,\n  authn_user_id,\n  mode,\n  time_limit_min,\n  date,\n  client_fingerprint_id,\n}: {\n  assessment: Assessment;\n  user_id: string;\n  authn_user_id: string;\n  mode: AssessmentInstance['mode'];\n  time_limit_min: number | null;\n  date: Date;\n  client_fingerprint_id: string | null;\n}): Promise<string> {\n  return await sqldb.runInTransactionAsync(async () => {\n    let group_id: string | null = null;\n    if (assessment.group_work) {\n      group_id = await getGroupId(assessment.id, user_id);\n      if (group_id == null) {\n        throw new error.HttpStatusError(403, 'No group found for this user in this assessment');\n      }\n    }\n\n    const { assessment_instance_id, created } = await sqldb.queryRow(\n      sql.insert_assessment_instance,\n      {\n        assessment_id: assessment.id,\n        group_id,\n        user_id,\n        mode,\n        time_limit_min,\n        date,\n        client_fingerprint_id,\n        authn_user_id,\n      },\n      z.object({ assessment_instance_id: IdSchema, created: z.boolean() }),\n    );\n\n    // Only update the assessment instance if a new instance was created.\n    if (created) {\n      await updateAssessmentInstance(assessment_instance_id, authn_user_id, false);\n    }\n\n    return assessment_instance_id;\n  });\n}\n\n/**\n * Add new questions to the assessment instance and regrade it if necessary.\n *\n * @param assessment_instance_id - The assessment instance to grade.\n * @param authn_user_id - The current authenticated user.\n * @param recomputeGrades - Whether to recompute the grades after adding the questions. Should only be false when the caller takes responsibility for grading the assessment instance later.\n * @returns Whether the assessment instance was updated.\n */\nexport async function updateAssessmentInstance(\n  assessment_instance_id: string,\n  authn_user_id: string,\n  recomputeGrades = true,\n): Promise<boolean> {\n  const updated = await sqldb.runInTransactionAsync(async () => {\n    const assessmentInstance = await sqldb.queryOptionalRow(\n      sql.select_and_lock_assessment_instance,\n      { assessment_instance_id },\n      AssessmentInstanceSchema,\n    );\n    if (assessmentInstance == null) {\n      throw new error.HttpStatusError(404, 'Assessment instance not found');\n    }\n    if (!assessmentInstance.open) {\n      // Silently return without updating\n      return false;\n    }\n\n    // Insert any new questions not previously in the assessment instance\n    const newInstanceQuestionIds = await sqldb.queryRows(\n      sql.insert_instance_questions,\n      { assessment_instance_id, assessment_id: assessmentInstance.assessment_id, authn_user_id },\n      IdSchema,\n    );\n\n    const newMaxPoints = await sqldb.queryOptionalRow(\n      sql.update_assessment_instance_max_points,\n      { assessment_instance_id, authn_user_id },\n      AssessmentInstanceSchema.pick({ max_points: true, max_bonus_points: true }),\n    );\n    // If assessment was not updated, grades do not need to be recomputed.\n    if (newInstanceQuestionIds.length === 0 && newMaxPoints == null) return false;\n\n    // if updated, regrade to pick up max_points changes, etc.\n    if (recomputeGrades) {\n      await sqldb.callOneRowAsync('assessment_instances_grade', [\n        assessment_instance_id,\n        authn_user_id,\n        null, // credit\n        true, // only_log_if_score_updated\n      ]);\n    }\n    return true;\n  });\n  // Don't try to update LTI score if the assessment wasn't updated.\n  if (updated && recomputeGrades) {\n    // NOTE: It's important that this is run outside of `runInTransaction`\n    // above. This will hit the network, and as a rule we don't do any\n    // potentially long-running work inside of a transaction.\n    await ltiOutcomes.updateScore(assessment_instance_id);\n  }\n  return updated;\n}\n\n/**\n * Grade all questions in an assessment instance and (optionally) close it.\n *\n * All user-facing routes should set `requireOpen` to true. However, internal\n * functions that asynchronously grade exams can set `requireOpen` to false\n * if needed.\n *\n * @param assessment_instance_id - The assessment instance to grade.\n * @param user_id - The current effective user.\n * @param authn_user_id - The current authenticated user.\n * @param requireOpen - Whether to enforce that the assessment instance is open before grading.\n * @param close - Whether to close the assessment instance after grading.\n * @param overrideGradeRate - Whether to override grade rate limits.\n */\nexport async function gradeAssessmentInstance(\n  assessment_instance_id: string,\n  user_id: string | null,\n  authn_user_id: string | null,\n  requireOpen: boolean,\n  close: boolean,\n  overrideGradeRate: boolean,\n  client_fingerprint_id: string | null,\n): Promise<void> {\n  debug('gradeAssessmentInstance()');\n  overrideGradeRate = close || overrideGradeRate;\n\n  if (requireOpen || close) {\n    await sqldb.runInTransactionAsync(async () => {\n      const assessmentInstance = await sqldb.queryOptionalRow(\n        sql.select_and_lock_assessment_instance,\n        { assessment_instance_id },\n        AssessmentInstanceSchema,\n      );\n      if (assessmentInstance == null) {\n        throw new error.HttpStatusError(404, 'Assessment instance not found');\n      }\n      if (!assessmentInstance.open) {\n        throw new error.HttpStatusError(403, 'Assessment instance is not open');\n      }\n\n      if (close) {\n        // If we're supposed to close the assessment, do it *before* we\n        // we start grading. This avoids a race condition where the student\n        // makes an additional submission while grading is already in progress.\n        await sqldb.queryAsync(sql.close_assessment_instance, {\n          assessment_instance_id,\n          authn_user_id,\n          client_fingerprint_id,\n        });\n      }\n    });\n  }\n\n  const variants = await sqldb.queryRows(\n    sql.select_variants_for_assessment_instance_grading,\n    { assessment_instance_id },\n    z.object({ variant: VariantSchema, question: QuestionSchema, variant_course: CourseSchema }),\n  );\n  debug('gradeAssessmentInstance()', 'selected variants', 'count:', variants.length);\n  await async.eachSeries(variants, async (row) => {\n    debug('gradeAssessmentInstance()', 'loop', 'variant.id:', row.variant.id);\n    const check_submission_id = null;\n    await gradeVariant(\n      row.variant,\n      check_submission_id,\n      row.question,\n      row.variant_course,\n      user_id,\n      authn_user_id,\n      overrideGradeRate,\n    );\n  });\n  // The `grading_needed` flag was set by the closing query above. Once we've\n  // successfully graded every part of the assessment instance, set the flag to\n  // false so that we don't try to grade it again in the future.\n  //\n  // This flag exists only to handle the case where we close the exam but then\n  // the PrairieLearn server crashes before we can grade it. In that case, the\n  // `autoFinishExams` cronjob will detect that the assessment instance hasn't\n  // been fully graded and will grade any ungraded portions of it.\n  //\n  // There's a potential race condition here where the `autoFinishExams` cronjob\n  // runs after closing the instance but before the above calls to\n  // `gradeVariant` have finished. In that case, we'll concurrently try to grade\n  // the same variant twice. This shouldn't impact correctness, as\n  // `gradeVariant` is resilient to being run multiple times concurrently. The\n  // only bad thing that will happen is that we'll have wasted some work, but\n  // that's acceptable.\n  await sqldb.queryAsync(sql.unset_grading_needed, { assessment_instance_id });\n}\n\nconst AssessmentInfoSchema = z.object({\n  assessment_label: z.string(),\n  course_instance_id: IdSchema,\n  course_id: IdSchema,\n});\n\nconst InstancesToGradeSchema = z.object({\n  assessment_instance_id: IdSchema,\n  instance_number: z.number(),\n  username: z.string(),\n});\n\n/**\n * Grade all assessment instances and (optionally) close them.\n *\n * @param assessment_id - The assessment to grade.\n * @param user_id - The current user performing the update.\n * @param authn_user_id - The current authenticated user.\n * @param close - Whether to close the assessment instances after grading.\n * @param overrideGradeRate - Whether to override grade rate limits.\n * @returns The ID of the new job sequence.\n */\nexport async function gradeAllAssessmentInstances(\n  assessment_id: string,\n  user_id: string,\n  authn_user_id: string,\n  close: boolean,\n  overrideGradeRate: boolean,\n): Promise<string> {\n  debug('gradeAllAssessmentInstances()');\n  const { assessment_label, course_instance_id, course_id } = await sqldb.queryRow(\n    sql.select_assessment_info,\n    { assessment_id },\n    AssessmentInfoSchema,\n  );\n\n  const serverJob = await createServerJob({\n    courseId: course_id,\n    courseInstanceId: course_instance_id,\n    assessmentId: assessment_id,\n    userId: user_id,\n    authnUserId: authn_user_id,\n    type: 'grade_all_assessment_instances',\n    description: 'Grade all assessment instances for ' + assessment_label,\n  });\n\n  serverJob.executeInBackground(async (job) => {\n    job.info('Grading assessment instances for ' + assessment_label);\n\n    const instances = await sqldb.queryRows(\n      sql.select_instances_to_grade,\n      { assessment_id },\n      InstancesToGradeSchema,\n    );\n    job.info(instances.length === 1 ? 'One instance found' : instances.length + ' instances found');\n    await async.eachSeries(instances, async (row) => {\n      job.info(`Grading assessment instance #${row.instance_number} for ${row.username}`);\n      const requireOpen = true;\n      await gradeAssessmentInstance(\n        row.assessment_instance_id,\n        user_id,\n        authn_user_id,\n        requireOpen,\n        close,\n        overrideGradeRate,\n        null,\n      );\n    });\n  });\n\n  return serverJob.jobSequenceId;\n}\n\n/**\n * Updates statistics for all assessments in a course instance, but only if an\n * update is needed.\n *\n * @param course_instance_id - The course instance ID.\n */\nexport async function updateAssessmentStatisticsForCourseInstance(\n  course_instance_id: string,\n): Promise<void> {\n  const rows = await sqldb.queryRows(\n    sql.select_assessments_for_statistics_update,\n    { course_instance_id },\n    IdSchema,\n  );\n  await async.eachLimit(rows, 3, updateAssessmentStatistics);\n}\n\n/**\n * Updates statistics for an assessment, if needed.\n *\n * @param assessment_id - The assessment ID.\n */\nexport async function updateAssessmentStatistics(assessment_id: string): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    // lock the assessment\n    await sqldb.queryOneRowAsync(sql.select_assessment_lock, { assessment_id });\n\n    // check whether we need to update the statistics\n    const needs_statistics_update = await sqldb.queryRow(\n      sql.select_assessment_needs_statisics_update,\n      { assessment_id },\n      z.boolean(),\n    );\n    if (!needs_statistics_update) return;\n\n    // update the statistics\n    await sqldb.queryOneRowAsync(sql.update_assessment_statisics, { assessment_id });\n  });\n}\n\nexport async function updateAssessmentInstanceScore(\n  assessment_instance_id: string,\n  score_perc: number,\n  authn_user_id: string,\n): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    const { max_points } = await sqldb.queryRow(\n      sql.select_and_lock_assessment_instance,\n      { assessment_instance_id },\n      AssessmentInstanceSchema,\n    );\n    const points = (score_perc * (max_points ?? 0)) / 100;\n    await sqldb.queryAsync(sql.update_assessment_instance_score, {\n      assessment_instance_id,\n      score_perc,\n      points,\n      authn_user_id,\n    });\n  });\n}\n\nexport async function updateAssessmentInstancePoints(\n  assessment_instance_id: string,\n  points: number,\n  authn_user_id: string,\n): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    const { max_points } = await sqldb.queryRow(\n      sql.select_and_lock_assessment_instance,\n      { assessment_instance_id },\n      AssessmentInstanceSchema,\n    );\n    const score_perc = (points / (max_points != null && max_points > 0 ? max_points : 1)) * 100;\n    await sqldb.queryAsync(sql.update_assessment_instance_score, {\n      assessment_instance_id,\n      score_perc,\n      points,\n      authn_user_id,\n    });\n  });\n}\n\n/**\n * Selects a log of all events associated to an assessment instance.\n *\n * @param assessment_instance_id - The ID of the assessment instance.\n * @param include_files - A flag indicating if submitted files should be included in the\n * log.\n * @returns the results of the log query.\n */\nexport async function selectAssessmentInstanceLog(\n  assessment_instance_id: string,\n  include_files: boolean,\n): Promise<InstanceLogEntry[]> {\n  const log: InstanceLogEntry[] = await sqldb.queryRows(\n    sql.assessment_instance_log,\n    { assessment_instance_id, include_files },\n    InstanceLogSchema,\n  );\n  const fingerprintNumbers = {};\n  let i = 1;\n  log.forEach((row) => {\n    if (row.client_fingerprint) {\n      if (!fingerprintNumbers[row.client_fingerprint.id]) {\n        fingerprintNumbers[row.client_fingerprint.id] = i;\n        i++;\n      }\n      row.client_fingerprint_number = fingerprintNumbers[row.client_fingerprint.id];\n    }\n  });\n  return log;\n}\n\nexport async function selectAssessmentInstanceLogCursor(\n  assessment_instance_id,\n  include_files,\n): Promise<sqldb.CursorIterator<InstanceLogEntry>> {\n  return sqldb.queryValidatedCursor(\n    sql.assessment_instance_log,\n    { assessment_instance_id, include_files },\n    InstanceLogSchema,\n  );\n}\n\nexport async function updateAssessmentQuestionStats(assessment_question_id: string): Promise<void> {\n  await sqldb.queryAsync(sql.calculate_stats_for_assessment_question, { assessment_question_id });\n}\n\nexport async function updateAssessmentQuestionStatsForAssessment(\n  assessment_id: string,\n): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    const assessment_questions = await sqldb.queryRows(\n      sql.select_assessment_questions,\n      { assessment_id },\n      IdSchema,\n    );\n    await async.eachLimit(assessment_questions, 3, updateAssessmentQuestionStats);\n    await sqldb.queryAsync(sql.update_assessment_stats_last_updated, { assessment_id });\n  });\n}\n\nexport async function deleteAssessmentInstance(\n  assessment_id: string,\n  assessment_instance_id: string,\n  authn_user_id: string,\n): Promise<void> {\n  const deleted_id = await sqldb.queryOptionalRow(\n    sql.delete_assessment_instance,\n    { assessment_id, assessment_instance_id, authn_user_id },\n    IdSchema,\n  );\n  if (deleted_id == null) {\n    throw new error.HttpStatusError(\n      403,\n      'This assessment instance does not exist in this assessment.',\n    );\n  }\n}\n\nexport async function deleteAllAssessmentInstancesForAssessment(\n  assessment_id: string,\n  authn_user_id: string,\n): Promise<void> {\n  await sqldb.queryAsync(sql.delete_all_assessment_instances_for_assessment, {\n    assessment_id,\n    authn_user_id,\n  });\n}\n\n/**\n * This is used to conditionally display/permit a shortcut to delete the\n * assessment instance. Usually, the only way to delete an assessment instance\n * is from the \"Students\" tab of an assessment. However, when a staff member is\n * iterating on or testing an assessment, it can be tedious to constantly go\n * back to that page to delete the instance in order to recreate it.\n *\n * The shortcut is a \"Regenerate assessment instance\" button on the assessment\n * instance page and instance question page. It's only displayed if the user\n * has the necessary permissions: either \"Previewer\" or above access on the\n * course, or \"Student Data Viewer\" or above access on the course instance.\n * We're deliberately permissive with these permissions to allow \"untrusted\"\n * course staff to e.g. perform quality control on assessments.\n *\n * We have an extra check: the instance must have been created by a user that\n * was an instructor at the time of creation. This addresses the case where\n * some user was an enrolled student in course instance X and was later added\n * as course staff to course instance Y. In this case, the user should not be\n * able to delete their old assessment instances in course instance X. This\n * check is performed with the `assessment_instances.include_in_statistics`\n * column, which reflects whether or not the user was an instructor at the time\n * of creation. We'll rename this column to something more general, e.g.\n * `created_by_instructor`, in a future migration.\n *\n * There's one exception to the above check: the example course, where\n * `include_in_statistics` is generally `false` even when instructors create\n * assessment instances; this is because the example course has weird implicit\n * permissions.\n *\n * Note that we check for `authn_` permissions specifically. This ensures that\n * the menu appears for both \"student view\" and \"student view without access\n * restrictions\".\n *\n * @returns {boolean} Whether or not the user should be allowed to delete the assessment instance.\n */\nexport function canDeleteAssessmentInstance(resLocals): boolean {\n  return (\n    // Check for permissions.\n    (resLocals.authz_data.authn_has_course_permission_preview ||\n      resLocals.authz_data.authn_has_course_instance_permission_view) &&\n    // Check that the assessment instance belongs to this user, or that the\n    // user belongs to the group that created the assessment instance.\n    resLocals.authz_result.authorized_edit &&\n    // Check that the assessment instance was created by an instructor; bypass\n    // this check if the course is an example course.\n    (!resLocals.assessment_instance.include_in_statistics || resLocals.course.example_course)\n  );\n}\n\nexport async function selectAssessmentInstanceLastSubmissionDate(assessment_instance_id: string) {\n  return await sqldb.queryRow(\n    sql.select_assessment_instance_last_submission_date,\n    { assessment_instance_id },\n    DateFromISOString.nullable(),\n  );\n}\n"]}