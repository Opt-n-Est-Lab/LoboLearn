{"version":3,"file":"base64-util.js","sourceRoot":"","sources":["../../src/lib/base64-util.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAE9C,MAAM,IAAI,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC7E,MAAM,IAAI,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAEpG,MAAM,UAAU,gBAAgB,CAAC,GAAW;IAC1C,0DAA0D;IAC1D,6CAA6C;IAC7C,kCAAkC;IAClC,IAAI,CAAC;QACH,OAAO,IAAI,CACT,kBAAkB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE;YAC/D,OAAO,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,GAAG,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACtD,CAAC,CAAC,CACH,CAAC;IACJ,CAAC;IAAC,MAAM,CAAC;QACP,MAAM,CAAC,KAAK,CAAC,qEAAqE,GAAG,EAAE,CAAC,CAAC;QACzF,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,GAAW;IAC1C,6EAA6E;IAC7E,IAAI,CAAC;QACH,OAAO,kBAAkB,CACvB,IAAI,CAAC,GAAG,CAAC;aACN,KAAK,CAAC,EAAE,CAAC;aACT,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACT,OAAO,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/D,CAAC,CAAC;aACD,IAAI,CAAC,EAAE,CAAC,CACZ,CAAC;IACJ,CAAC;IAAC,MAAM,CAAC;QACP,MAAM,CAAC,KAAK,CAAC,qEAAqE,GAAG,EAAE,CAAC,CAAC;QACzF,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC","sourcesContent":["import { logger } from '@prairielearn/logger';\n\nconst atob = (s: string) => String.fromCharCode(...Buffer.from(s, 'base64'));\nconst btoa = (s: string) => Buffer.from(s.split('').map((c) => c.charCodeAt(0))).toString('base64');\n\nexport function b64EncodeUnicode(str: string) {\n  // (1) use encodeURIComponent to get percent-encoded UTF-8\n  // (2) convert percent encodings to raw bytes\n  // (3) convert raw bytes to Base64\n  try {\n    return btoa(\n      encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n        return String.fromCharCode(parseInt('0x' + p1, 16));\n      }),\n    );\n  } catch {\n    logger.error(`b64EncodeUnicode: returning empty string because failed to encode ${str}`);\n    return '';\n  }\n}\n\nexport function b64DecodeUnicode(str: string) {\n  // Going backwards: from bytestream, to percent-encoding, to original string.\n  try {\n    return decodeURIComponent(\n      atob(str)\n        .split('')\n        .map((c) => {\n          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(''),\n    );\n  } catch {\n    logger.error(`b64DecodeUnicode: returning empty string because failed to decode ${str}`);\n    return '';\n  }\n}\n"]}