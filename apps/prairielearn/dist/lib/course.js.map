{"version":3,"file":"course.js","sourceRoot":"","sources":["../../src/lib/course.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\n\nimport { HttpStatusError } from '@prairielearn/error';\nimport * as namedLocks from '@prairielearn/named-locks';\nimport * as sqldb from '@prairielearn/postgres';\n\nimport {\n  getCourseCommitHash,\n  getLockNameForCoursePath,\n  getOrUpdateCourseCommitHash,\n  selectCourseById,\n  updateCourseCommitHash,\n} from '../models/course.js';\nimport { syncDiskToSqlWithLock } from '../sync/syncFromDisk.js';\n\nimport * as chunks from './chunks.js';\nimport { config } from './config.js';\nimport { IdSchema, type User, UserSchema } from './db-types.js';\nimport { type ServerJobResult, createServerJob } from './server-jobs.js';\n\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\n/**\n * Check that an assessment_instance_id really belongs to the given course_instance_id\n *\n * @param assessment_instance_id - The assessment instance to check.\n * @param course_instance_id - The course instance it should belong to.\n */\nexport async function checkAssessmentInstanceBelongsToCourseInstance(\n  assessment_instance_id: string,\n  course_instance_id: string,\n): Promise<void> {\n  if (\n    (await sqldb.queryOptionalRow(\n      sql.check_belongs,\n      { assessment_instance_id, course_instance_id },\n      IdSchema,\n    )) == null\n  ) {\n    throw new HttpStatusError(403, 'Access denied');\n  }\n}\n\n/**\n * Return the name and UID (email) for every owner of the specified course.\n *\n * @param course_id The ID of the course.\n */\nexport async function getCourseOwners(course_id: string): Promise<User[]> {\n  return await sqldb.queryRows(sql.select_owners, { course_id }, UserSchema);\n}\n\nexport async function pullAndUpdateCourse({\n  courseId,\n  userId,\n  authnUserId,\n  path,\n  branch,\n  repository,\n  commit_hash,\n}: {\n  courseId: string;\n  userId: string | null;\n  authnUserId: string | null;\n  path?: string | null;\n  branch?: string | null;\n  repository?: string | null;\n  commit_hash?: string | null;\n}): Promise<{ jobSequenceId: string; jobPromise: Promise<ServerJobResult> }> {\n  const serverJob = await createServerJob({\n    courseId,\n    userId: userId ?? undefined,\n    authnUserId: authnUserId ?? undefined,\n    type: 'sync',\n    description: 'Pull from remote git repository',\n  });\n\n  const gitEnv = process.env;\n  if (config.gitSshCommand != null) {\n    gitEnv.GIT_SSH_COMMAND = config.gitSshCommand;\n  }\n\n  const jobPromise = serverJob.execute(async (job) => {\n    if (path === undefined || branch === undefined || repository === undefined) {\n      const course_data = await selectCourseById(courseId);\n      path = course_data.path;\n      branch = course_data.branch;\n      repository = course_data.repository;\n      commit_hash = course_data.commit_hash;\n    }\n    if (!path) {\n      job.fail('Path is not set for this course. Exiting...');\n      return;\n    }\n    if (!branch || !repository) {\n      job.fail('Git repository or branch are not set for this course. Exiting...');\n      return;\n    }\n\n    const lockName = getLockNameForCoursePath(path);\n    await namedLocks.doWithLock(\n      lockName,\n      {\n        timeout: 5000,\n        onNotAcquired: () => {\n          job.fail('Another user is already syncing or modifying this course.');\n        },\n      },\n      async () => {\n        let startGitHash: string | null = null;\n\n        // These should be set by the time we get here, but checking to allow typing to assume non-null.\n        if (!path || !branch || !repository) {\n          job.fail('Invalid state');\n          return;\n        }\n\n        const gitOptions = { cwd: path, env: gitEnv };\n        const coursePathExists = await fs.pathExists(path);\n        if (!coursePathExists) {\n          // path does not exist, start with 'git clone'\n          job.info('Clone from remote git repository');\n          await job.exec('git', ['clone', '-b', branch, repository, path], {\n            // Executed in the root directory, but this shouldn't really matter.\n            cwd: '/',\n            env: gitEnv,\n          });\n        } else {\n          // path exists, update remote origin address, then 'git fetch' and reset to latest with 'git reset'\n\n          startGitHash = await getOrUpdateCourseCommitHash({\n            id: courseId,\n            path,\n            commit_hash,\n          });\n\n          job.info('Updating to latest remote origin address');\n          await job.exec('git', ['remote', 'set-url', 'origin', repository], gitOptions);\n\n          job.info('Fetch from remote git repository');\n          await job.exec('git', ['fetch'], gitOptions);\n\n          job.info('Restore staged and unstaged changes');\n          await job.exec('git', ['restore', '--staged', '--worktree', '.'], gitOptions);\n\n          job.info('Clean local files not in remote git repository');\n          await job.exec('git', ['clean', '-fdx'], gitOptions);\n\n          job.info('Check out current branch');\n          await job.exec('git', ['checkout', branch], gitOptions);\n\n          job.info('Reset state to remote git repository');\n          await job.exec('git', ['reset', '--hard', `origin/${branch}`], gitOptions);\n        }\n\n        // After either cloning or fetching and resetting from Git, we'll load the\n        // current commit hash. Note that we don't commit this to the database until\n        // after we've synced the changes to the database and generated chunks. This\n        // ensures that if the sync fails, we'll sync from the same starting commit\n        // hash next time.\n        const endGitHash = await getCourseCommitHash(path);\n\n        job.info('Sync git repository to database');\n        const syncResult = await syncDiskToSqlWithLock(courseId, path, job);\n        if (syncResult.status === 'sharing_error') {\n          if (startGitHash) {\n            await job.exec('git', ['reset', '--hard', startGitHash], gitOptions);\n          }\n          job.fail('Sync completely failed due to invalid question sharing edit.');\n          return;\n        }\n\n        if (config.chunksGenerator) {\n          const chunkChanges = await chunks.updateChunksForCourse({\n            coursePath: path,\n            courseId,\n            courseData: syncResult.courseData,\n            oldHash: startGitHash,\n            newHash: endGitHash,\n          });\n          chunks.logChunkChangesToJob(chunkChanges, job);\n        }\n\n        await updateCourseCommitHash({ id: courseId, path });\n\n        if (syncResult.hadJsonErrors) {\n          job.fail('One or more JSON files contained errors and were unable to be synced.');\n        }\n      },\n    );\n  });\n\n  return { jobSequenceId: serverJob.jobSequenceId, jobPromise };\n}\n"]}