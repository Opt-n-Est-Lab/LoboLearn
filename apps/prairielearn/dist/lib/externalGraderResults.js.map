{"version":3,"file":"externalGraderResults.js","sourceRoot":"","sources":["../../src/lib/externalGraderResults.ts"],"names":[],"mappings":"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","sourcesContent":["import { S3 } from '@aws-sdk/client-s3';\nimport {\n  DeleteMessageCommand,\n  GetQueueUrlCommand,\n  ReceiveMessageCommand,\n  type ReceiveMessageResult,\n  SQSClient,\n} from '@aws-sdk/client-sqs';\n\nimport * as error from '@prairielearn/error';\nimport { logger } from '@prairielearn/logger';\nimport * as sqldb from '@prairielearn/postgres';\nimport * as Sentry from '@prairielearn/sentry';\n\nimport { makeAwsClientConfig, makeS3ClientConfig } from './aws.js';\nimport { config } from './config.js';\nimport { IdSchema } from './db-types.js';\nimport { deferredPromise } from './deferred.js';\nimport { processGradingResult } from './externalGrader.js';\nimport * as externalGraderCommon from './externalGraderCommon.js';\nimport { gradingJobStatusUpdated } from './externalGradingSocket.js';\n\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nconst abortController = new AbortController();\nconst processingFinished = deferredPromise();\n\nexport async function init() {\n  // If we're not configured to use AWS, don't try to do anything here\n  if (!config.externalGradingUseAws) return;\n\n  const sqs = new SQSClient(makeAwsClientConfig());\n  const queueUrl = await loadQueueUrl(sqs);\n\n  // Start work in an IIFE so we can keep going asynchronously\n  // after we return to the caller.\n  (async () => {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Spin until we can get at least one message from the queue.\n      let messages: ReceiveMessageResult['Messages'];\n      while (messages === undefined) {\n        // Only attempt to abort before we receive any messages. Once we\n        // receive them, we should not mark ourselves as finished until we've\n        // actually processed all of them.\n        if (abortController.signal.aborted) {\n          processingFinished.resolve(null);\n          return;\n        }\n\n        try {\n          const data = await sqs.send(\n            new ReceiveMessageCommand({\n              MaxNumberOfMessages: 10,\n              QueueUrl: queueUrl,\n              WaitTimeSeconds: 20,\n            }),\n          );\n          messages = data.Messages;\n        } catch (err) {\n          logger.error('Error receiving messages from SQS', err);\n          Sentry.captureException(err);\n          continue;\n        }\n      }\n\n      // Wait for all messages to be processed.\n      await Promise.all(\n        messages.map(async (message) => {\n          try {\n            if (!message.Body) throw new Error('Message is missing Body');\n            if (!message.ReceiptHandle) throw new Error('Message is missing ReceiptHandle');\n\n            const parsedMessage = JSON.parse(message.Body);\n            const receiptHandle = message.ReceiptHandle;\n\n            await processMessage(parsedMessage);\n\n            await sqs.send(\n              new DeleteMessageCommand({\n                QueueUrl: queueUrl,\n                ReceiptHandle: receiptHandle,\n              }),\n            );\n          } catch (err) {\n            logger.error('Error processing external grader results', err);\n            Sentry.captureException(err);\n          }\n        }),\n      );\n    }\n  })().then(() => {\n    // Do nothing\n  });\n}\n\nexport async function stop() {\n  if (!config.externalGradingUseAws) return;\n\n  if (abortController.signal.aborted) {\n    throw new Error('Already stopped');\n  }\n\n  abortController.abort();\n\n  // The main work loop will resolve this deferred promise when it's finished\n  // with any current processing.\n  await processingFinished.promise;\n}\n\n/**\n * @returns The URL of the results queue.\n */\nasync function loadQueueUrl(sqs: SQSClient): Promise<string> {\n  logger.verbose(\n    `External grading results queue ${config.externalGradingResultsQueueName}: getting URL...`,\n  );\n  const data = await sqs.send(\n    new GetQueueUrlCommand({ QueueName: config.externalGradingResultsQueueName }),\n  );\n  const queueUrl = data.QueueUrl;\n  if (!queueUrl) {\n    throw new Error(`Could not get URL for queue ${config.externalGradingResultsQueueName}`);\n  }\n  logger.verbose(\n    `External grading results queue ${config.externalGradingResultsQueueName}: got URL ${queueUrl}`,\n  );\n  return queueUrl;\n}\n\nasync function processMessage(data: {\n  jobId: string;\n  event: string;\n  data: {\n    receivedTime: string;\n  };\n}) {\n  let jobId: string;\n  try {\n    jobId = IdSchema.parse(data.jobId);\n  } catch {\n    throw new error.AugmentedError('Message does not contain a valid grading job id.', { data });\n  }\n\n  logger.verbose('Processing external grading job result message', {\n    grading_job_id: jobId,\n    ...data,\n  });\n  if (data.event === 'job_received') {\n    await sqldb.queryOneRowAsync(sql.update_grading_received_time, {\n      grading_job_id: jobId,\n      received_time: data.data.receivedTime,\n    });\n    await gradingJobStatusUpdated(jobId);\n    return;\n  } else if (data.event === 'grading_result') {\n    // Figure out where we can fetch results from.\n    const jobDetails = await sqldb.queryOneRowAsync(sql.get_job_details, {\n      grading_job_id: jobId,\n    });\n    const s3Bucket = jobDetails.rows[0].s3_bucket;\n    const s3RootKey = jobDetails.rows[0].s3_root_key;\n\n    // Depending on the size of the results, the grader may have included\n    // them in the message body. If so, we'll use them directly. If we\n    // don't find the results data in the message body, we'll fetch the\n    // results from S3 instead.\n    if (data.data) {\n      // We have the data!\n      await processResults(jobId, data.data);\n      return;\n    } else {\n      // We should fetch it from S3, and then process it\n      const s3Client = new S3(makeS3ClientConfig());\n      const data = await s3Client.getObject({\n        Bucket: s3Bucket,\n        Key: `${s3RootKey}/results.json`,\n        ResponseContentType: 'application/json',\n      });\n      if (!data.Body) throw new Error('No body in S3 response');\n      await processResults(jobId, await data.Body.transformToString());\n      return;\n    }\n  } else {\n    throw new error.AugmentedError(`Unknown grading event: ${data.event}`, { data });\n  }\n}\n\nasync function processResults(jobId: string, data: Record<string, any> | string | Buffer) {\n  await processGradingResult(externalGraderCommon.makeGradingResult(jobId, data));\n}\n"]}