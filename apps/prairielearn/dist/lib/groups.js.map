{"version":3,"file":"groups.js","sourceRoot":"","sources":["../../src/lib/groups.ts"],"names":[],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport { z } from 'zod';\n\nimport * as error from '@prairielearn/error';\nimport * as sqldb from '@prairielearn/postgres';\n\nimport { selectCourseInstanceById } from '../models/course-instances.js';\nimport { userIsInstructorInAnyCourse } from '../models/course-permissions.js';\nimport { selectCourseById } from '../models/course.js';\nimport { getEnrollmentForUserInCourseInstance } from '../models/enrollment.js';\nimport { selectOptionalUserByUid } from '../models/user.js';\n\nimport {\n  type GroupConfig,\n  GroupConfigSchema,\n  GroupRoleSchema,\n  GroupSchema,\n  type GroupUserRole,\n  IdSchema,\n  type User,\n  UserSchema,\n} from './db-types.js';\nimport { idsEqual } from './id.js';\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nexport class GroupOperationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'GroupOperationError';\n  }\n}\n\nconst RoleAssignmentSchema = z.object({\n  user_id: z.string(),\n  uid: z.string(),\n  role_name: z.string(),\n  group_role_id: z.string(),\n});\ntype RoleAssignment = z.infer<typeof RoleAssignmentSchema>;\n\nconst GroupRoleWithCountSchema = GroupRoleSchema.extend({\n  count: z.number(),\n});\ntype GroupRoleWithCount = z.infer<typeof GroupRoleWithCountSchema>;\n\ninterface RolesInfo {\n  roleAssignments: Record<string, RoleAssignment[]>;\n  groupRoles: GroupRoleWithCount[];\n  validationErrors: GroupRoleWithCount[];\n  disabledRoles: string[];\n  rolesAreBalanced: boolean;\n  usersWithoutRoles: User[];\n}\n\nexport interface GroupInfo {\n  groupMembers: User[];\n  groupSize: number;\n  groupName: string;\n  joinCode: string;\n  start: boolean;\n  rolesInfo?: RolesInfo;\n}\n\ntype GroupRoleAssignment = Pick<GroupUserRole, 'group_role_id' | 'user_id'>;\n\nconst GroupForUpdateSchema = GroupSchema.extend({\n  cur_size: z.number(),\n  max_size: z.number().nullable(),\n  has_roles: z.boolean(),\n});\n\n/**\n * Gets the group config info for a given assessment id.\n */\nexport async function getGroupConfig(assessmentId: string): Promise<GroupConfig> {\n  return await sqldb.queryRow(\n    sql.get_group_config,\n    { assessment_id: assessmentId },\n    GroupConfigSchema,\n  );\n}\n\n/**\n * Returns the group id for the user's current group in an assessment, if it exists.\n * Used in checking whether the user is in a group or not.\n */\nexport async function getGroupId(assessmentId: string, userId: string): Promise<string | null> {\n  return await sqldb.queryOptionalRow(\n    sql.get_group_id,\n    { assessment_id: assessmentId, user_id: userId },\n    IdSchema,\n  );\n}\n\nexport async function getGroupInfo(group_id: string, groupConfig: GroupConfig): Promise<GroupInfo> {\n  const group = await sqldb.queryRow(sql.select_group, { group_id }, GroupSchema);\n  const groupMembers = await sqldb.queryRows(sql.select_group_members, { group_id }, UserSchema);\n\n  const needSize = (groupConfig.minimum ?? 0) - groupMembers.length;\n  const groupInfo: GroupInfo = {\n    groupMembers,\n    groupSize: groupMembers.length,\n    groupName: group.name,\n    joinCode: group.name + '-' + group.join_code,\n    start: needSize <= 0,\n  };\n\n  if (groupConfig.has_roles) {\n    const rolesInfo = await getRolesInfo(group_id, groupInfo.groupMembers);\n    groupInfo.start =\n      groupInfo.start &&\n      rolesInfo.rolesAreBalanced &&\n      rolesInfo.validationErrors.length === 0 &&\n      rolesInfo.usersWithoutRoles.length === 0;\n    groupInfo.rolesInfo = rolesInfo;\n  }\n\n  return groupInfo;\n}\n\n/**\n * A helper function to getGroupInfo that returns a data structure containing info about an\n * assessment's group roles.\n */\nasync function getRolesInfo(groupId: string, groupMembers: User[]): Promise<RolesInfo> {\n  // Get the current role assignments of the group\n  const result = await sqldb.queryRows(\n    sql.get_role_assignments,\n    { group_id: groupId },\n    RoleAssignmentSchema,\n  );\n  const roleAssignments = _.groupBy(result, 'uid');\n\n  // Get info on all group roles for the assessment\n  const groupRoles = await sqldb.queryRows(\n    sql.get_group_roles,\n    { group_id: groupId },\n    GroupRoleWithCountSchema,\n  );\n\n  // Identify errors for any roles where count is not between max and min (if they exist)\n  const validationErrors = groupRoles.filter(\n    (role) =>\n      (role.minimum && role.count < role.minimum) || (role.maximum && role.count > role.maximum),\n  );\n\n  // Identify any disabled roles based on group size, role minimums\n  const minimumRolesToFill = _.sum(groupRoles.map((role) => role.minimum ?? 0));\n  const optionalRoleNames = groupRoles\n    .filter((role) => (role.minimum ?? 0) === 0)\n    .map((role) => role.role_name);\n  const disabledRoles = groupMembers.length <= minimumRolesToFill ? optionalRoleNames : [];\n\n  // Check if any users have too many roles\n  const rolesAreBalanced =\n    groupMembers.length < minimumRolesToFill ||\n    Object.values(roleAssignments).every((roles) => roles.length === 1);\n\n  // Check if users have no roles\n  const usersWithoutRoles = groupMembers.filter(\n    (member) => roleAssignments[member.uid] === undefined,\n  );\n\n  return {\n    roleAssignments,\n    groupRoles,\n    validationErrors,\n    disabledRoles,\n    rolesAreBalanced,\n    usersWithoutRoles,\n  };\n}\n\n/**\n * This function assumes that the group has roles, so any caller must ensure\n * that it is only called in that scenario\n */\nexport async function getQuestionGroupPermissions(\n  instance_question_id: string,\n  group_id: string,\n  user_id: string,\n): Promise<{ can_submit: boolean; can_view: boolean }> {\n  const userPermissions = await sqldb.queryOptionalRow(\n    sql.select_question_permissions,\n    { instance_question_id, group_id, user_id },\n    z.object({ can_submit: z.boolean(), can_view: z.boolean() }),\n  );\n  return userPermissions ?? { can_submit: false, can_view: false };\n}\n\nexport async function getUserRoles(group_id: string, user_id: string) {\n  return await sqldb.queryRows(sql.select_user_roles, { group_id, user_id }, GroupRoleSchema);\n}\n\nasync function selectUserInCourseInstance({\n  uid,\n  course_instance_id,\n}: {\n  uid: string;\n  course_instance_id: string;\n}) {\n  const user = await selectOptionalUserByUid(uid);\n  if (!user) return null;\n\n  // To be part of a group, the user needs to either be enrolled in the course\n  // instance, or be an instructor\n  if (\n    (await sqldb.callRow(\n      'users_is_instructor_in_course_instance',\n      [user.user_id, course_instance_id],\n      z.boolean(),\n    )) ||\n    (await getEnrollmentForUserInCourseInstance({\n      course_instance_id,\n      user_id: user.user_id,\n    }))\n  ) {\n    return user;\n  }\n\n  // In the example course, any user with instructor access in any other\n  // course should have access and thus be allowed to be added to a group.\n  const course_instance = await selectCourseInstanceById(course_instance_id);\n  if (course_instance) {\n    const course = await selectCourseById(course_instance.course_id);\n    if (course?.example_course && (await userIsInstructorInAnyCourse({ user_id: user.user_id }))) {\n      return user;\n    }\n  }\n\n  // We do not distinguish between an invalid user and a user that is not in the course instance\n  return null;\n}\n\nexport async function addUserToGroup({\n  assessment_id,\n  group_id,\n  uid,\n  authn_user_id,\n  enforceGroupSize,\n}: {\n  assessment_id: string;\n  group_id: string;\n  uid: string;\n  authn_user_id: string;\n  enforceGroupSize: boolean;\n}) {\n  await sqldb.runInTransactionAsync(async () => {\n    const group = await sqldb.queryOptionalRow(\n      sql.select_and_lock_group,\n      { group_id, assessment_id },\n      GroupForUpdateSchema,\n    );\n    if (group == null) {\n      throw new GroupOperationError('Group does not exist.');\n    }\n\n    const user = await selectUserInCourseInstance({\n      uid,\n      course_instance_id: group.course_instance_id,\n    });\n    if (!user) {\n      throw new GroupOperationError(`User ${uid} is not enrolled in this course.`);\n    }\n\n    // This is technically susceptible to race conditions. That won't be an\n    // issue once we have a unique constraint for group membership.\n    const existingGroupId = await getGroupId(assessment_id, user.user_id);\n    if (existingGroupId != null) {\n      if (idsEqual(user.user_id, authn_user_id)) {\n        throw new GroupOperationError('You are already in another group.');\n      } else {\n        throw new GroupOperationError('User is already in another group.');\n      }\n    }\n\n    if (enforceGroupSize && group.max_size != null && group.cur_size >= group.max_size) {\n      throw new GroupOperationError('Group is already full.');\n    }\n\n    // Find a group role. If none of the roles can be assigned, assign no role.\n    const groupRoleId = group.has_roles\n      ? await sqldb.queryOptionalRow(\n          sql.select_suitable_group_role,\n          { assessment_id, group_id: group.id, cur_size: group.cur_size },\n          IdSchema,\n        )\n      : null;\n\n    await sqldb.queryAsync(sql.insert_group_user, {\n      group_id: group.id,\n      user_id: user.user_id,\n      group_config_id: group.group_config_id,\n      assessment_id,\n      authn_user_id,\n      group_role_id: groupRoleId,\n    });\n  });\n}\n\nexport async function joinGroup(\n  fullJoinCode: string,\n  assessment_id: string,\n  uid: string,\n  authn_user_id: string,\n): Promise<void> {\n  const splitJoinCode = fullJoinCode.split('-');\n  if (splitJoinCode.length !== 2 || splitJoinCode[1].length !== 4) {\n    // the join code input by user is not valid (not in format of groupname+4-character)\n    throw new GroupOperationError('The join code has an incorrect format');\n  }\n\n  const group_name = splitJoinCode[0];\n  const join_code = splitJoinCode[1].toUpperCase();\n\n  try {\n    await sqldb.runInTransactionAsync(async () => {\n      const group = await sqldb.queryOptionalRow(\n        sql.select_and_lock_group_by_name,\n        { group_name, assessment_id },\n        GroupSchema,\n      );\n      if (group == null || group.join_code !== join_code) {\n        throw new GroupOperationError('Group does not exist.');\n      }\n      await addUserToGroup({\n        assessment_id,\n        group_id: group.id,\n        uid,\n        authn_user_id,\n        enforceGroupSize: true,\n      });\n    });\n  } catch (err) {\n    if (err instanceof GroupOperationError) {\n      throw new GroupOperationError(`Cannot join group \"${fullJoinCode}\": ${err.message}`);\n    }\n    throw err;\n  }\n}\n\nexport async function createGroup(\n  group_name: string,\n  assessment_id: string,\n  uids: string[],\n  authn_user_id: string,\n): Promise<void> {\n  if (group_name.length > 30) {\n    throw new GroupOperationError(\n      'The group name is too long. Use at most 30 alphanumerical characters.',\n    );\n  }\n  if (!group_name.match(/^[0-9a-zA-Z]+$/)) {\n    throw new GroupOperationError(\n      'The group name is invalid. Only alphanumerical characters (letters and digits) are allowed.',\n    );\n  }\n\n  if (uids.length === 0) {\n    throw new GroupOperationError('There must be at least one user in the group.');\n  }\n\n  try {\n    await sqldb.runInTransactionAsync(async () => {\n      let group_id;\n      try {\n        group_id = await sqldb.queryRow(\n          sql.create_group,\n          { assessment_id, authn_user_id, group_name },\n          IdSchema,\n        );\n      } catch (err) {\n        // 23505 is the Postgres error code for unique constraint violation\n        // (https://www.postgresql.org/docs/current/errcodes-appendix.html)\n        if (err.code === '23505' && err.constraint === 'unique_group_name') {\n          throw new GroupOperationError('Group name is already taken.');\n        }\n        // Any other error is unexpected and should be handled by the main processes\n        throw err;\n      }\n      for (const uid of uids) {\n        await addUserToGroup({\n          assessment_id,\n          group_id,\n          uid,\n          authn_user_id,\n          enforceGroupSize: false,\n        });\n      }\n    });\n  } catch (err) {\n    if (err instanceof GroupOperationError) {\n      throw new GroupOperationError(`Failed to create the group ${group_name}. ${err.message}`);\n    }\n    throw err;\n  }\n}\n\nexport async function createOrAddToGroup(\n  group_name: string,\n  assessment_id: string,\n  uids: string[],\n  authn_user_id: string,\n): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    const group = await sqldb.queryOptionalRow(\n      sql.select_and_lock_group_by_name,\n      { group_name, assessment_id },\n      GroupSchema,\n    );\n    if (group == null) {\n      await createGroup(group_name, assessment_id, uids, authn_user_id);\n    } else {\n      for (const uid of uids) {\n        await addUserToGroup({\n          assessment_id,\n          group_id: group.id,\n          uid,\n          authn_user_id,\n          enforceGroupSize: false,\n        });\n      }\n    }\n  });\n}\n\n/**\n * @param {GroupInfo} groupInfo\n * @param {string} leavingUserId\n * @returns {GroupRoleAssignment[]}\n */\nexport function getGroupRoleReassignmentsAfterLeave(\n  groupInfo: GroupInfo,\n  leavingUserId: string,\n): GroupRoleAssignment[] {\n  // Get the roleIds of the leaving user that need to be re-assigned to other users\n  const groupRoleAssignments = Object.values(groupInfo.rolesInfo?.roleAssignments ?? {}).flat();\n\n  const leavingUserRoleIds = groupRoleAssignments\n    .filter(({ user_id }) => idsEqual(user_id, leavingUserId))\n    .map(({ group_role_id }) => group_role_id);\n\n  const roleIdsToReassign =\n    groupInfo.rolesInfo?.groupRoles\n      .filter(\n        (role) =>\n          (role.minimum ?? 0) > 0 &&\n          role.count <= (role.minimum ?? 0) &&\n          leavingUserRoleIds.includes(role.id),\n      )\n      .map((role) => role.id) ?? [];\n\n  // Get group user to group role assignments, excluding the leaving user\n  const groupRoleAssignmentUpdates = groupRoleAssignments\n    .filter(({ user_id }) => !idsEqual(user_id, leavingUserId))\n    .map(({ user_id, group_role_id }) => ({ user_id, group_role_id }));\n\n  for (const roleId of roleIdsToReassign) {\n    // First, try to give the role to a user with no roles\n    const userIdWithNoRoles = groupInfo.groupMembers.find(\n      (m) =>\n        !idsEqual(m.user_id, leavingUserId) &&\n        groupRoleAssignmentUpdates.find(({ user_id }) => idsEqual(user_id, m.user_id)) ===\n          undefined,\n    )?.user_id;\n    if (userIdWithNoRoles !== undefined) {\n      groupRoleAssignmentUpdates.push({\n        user_id: userIdWithNoRoles,\n        group_role_id: roleId,\n      });\n      continue;\n    }\n\n    // Next, try to find a user with a non-required role and replace that role\n    const idxToUpdate = groupRoleAssignmentUpdates.findIndex(({ group_role_id }) => {\n      const roleMin =\n        groupInfo.rolesInfo?.groupRoles.find((role) => idsEqual(role.id, group_role_id))?.minimum ??\n        0;\n      return roleMin === 0;\n    });\n    if (idxToUpdate !== -1) {\n      groupRoleAssignmentUpdates[idxToUpdate].group_role_id = roleId;\n      continue;\n    }\n\n    // Finally, try to give the role to a user that doesn't already have it\n    const assigneeUserId = groupInfo.groupMembers.find(\n      (m) =>\n        !idsEqual(m.user_id, leavingUserId) &&\n        !groupRoleAssignmentUpdates.some(\n          (u) => idsEqual(u.group_role_id, roleId) && idsEqual(u.user_id, m.user_id),\n        ),\n    )?.user_id;\n    if (assigneeUserId !== undefined) {\n      groupRoleAssignmentUpdates.push({\n        user_id: assigneeUserId,\n        group_role_id: roleId,\n      });\n      continue;\n    }\n  }\n\n  return groupRoleAssignmentUpdates;\n}\n\nexport async function leaveGroup(\n  assessmentId: string,\n  userId: string,\n  authnUserId: string,\n  checkGroupId: string | null = null,\n): Promise<void> {\n  await sqldb.runInTransactionAsync(async () => {\n    const groupId = await getGroupId(assessmentId, userId);\n    if (groupId === null) {\n      throw new error.HttpStatusError(404, 'User is not part of a group in this assessment');\n    }\n    if (checkGroupId != null && !idsEqual(groupId, checkGroupId)) {\n      throw new error.HttpStatusError(\n        403,\n        'Group ID does not match the user ID and assessment ID provided',\n      );\n    }\n\n    const groupConfig = await getGroupConfig(assessmentId);\n\n    if (groupConfig.has_roles) {\n      const groupInfo = await getGroupInfo(groupId, groupConfig);\n\n      // Reassign roles if there is more than 1 user\n      const currentSize = groupInfo.groupMembers.length;\n      if (currentSize > 1) {\n        const groupRoleAssignmentUpdates = getGroupRoleReassignmentsAfterLeave(groupInfo, userId);\n        await sqldb.queryAsync(sql.update_group_roles, {\n          role_assignments: JSON.stringify(groupRoleAssignmentUpdates),\n          group_id: groupId,\n          authn_user_id: authnUserId,\n        });\n\n        // Groups with low enough size should only use required roles\n        const minRolesToFill = _.sum(\n          groupInfo.rolesInfo?.groupRoles.map((role) => role.minimum ?? 0),\n        );\n        if (currentSize - 1 <= minRolesToFill) {\n          await sqldb.queryAsync(sql.delete_non_required_roles, {\n            group_id: groupId,\n            assessment_id: assessmentId,\n          });\n        }\n      }\n    }\n\n    // Delete user from group and log\n    await sqldb.queryAsync(sql.delete_group_users, {\n      assessment_id: assessmentId,\n      group_id: groupId,\n      user_id: userId,\n      authn_user_id: authnUserId,\n    });\n  });\n}\n\nexport function canUserAssignGroupRoles(groupInfo: GroupInfo, user_id: string): boolean {\n  const assignerRoles =\n    groupInfo.rolesInfo?.groupRoles\n      .filter((role) => role.can_assign_roles)\n      .map((role) => role.id) ?? [];\n  const assignerUsers = Object.values(groupInfo.rolesInfo?.roleAssignments ?? {})\n    .flat()\n    .filter((assignment) => assignerRoles.some((id) => idsEqual(id, assignment.group_role_id)))\n    .map((assignment) => assignment.user_id);\n  if (assignerUsers.length === 0) {\n    // If none of the current users in the group has an assigner role, allow any\n    // user to assign roles by default\n    return true;\n  } else {\n    // Otherwise, check if current user is in the list of assigner users\n    return assignerUsers.some((id) => idsEqual(id, user_id));\n  }\n}\n\n/**\n * Updates the role assignments of users in a group, given the output from the GroupRoleTable component.\n */\nexport async function updateGroupRoles(\n  requestBody: Record<string, any>,\n  assessmentId: string,\n  groupId: string,\n  userId: string,\n  hasStaffPermission: boolean,\n  authnUserId: string,\n) {\n  await sqldb.runInTransactionAsync(async () => {\n    const groupConfig = await getGroupConfig(assessmentId);\n    const groupInfo = await getGroupInfo(groupId, groupConfig);\n\n    if (!hasStaffPermission && !canUserAssignGroupRoles(groupInfo, userId)) {\n      throw new error.HttpStatusError(403, 'User does not have permission to assign roles');\n    }\n\n    // Convert form data to valid input format for a SQL function\n    const roleKeys = Object.keys(requestBody).filter((key) => key.startsWith('user_role_'));\n    const roleAssignments = roleKeys.map((roleKey) => {\n      const [roleId, userId] = roleKey.replace('user_role_', '').split('-');\n      if (!groupInfo.groupMembers.some((member) => idsEqual(member.user_id, userId))) {\n        throw new error.HttpStatusError(403, `User ${userId} is not a member of this group`);\n      }\n      if (!groupInfo.rolesInfo?.groupRoles.some((role) => idsEqual(role.id, roleId))) {\n        throw new error.HttpStatusError(403, `Role ${roleId} does not exist for this assessment`);\n      }\n      return {\n        group_id: groupId,\n        user_id: userId,\n        group_role_id: roleId,\n      };\n    });\n\n    // If no one is being given a role with assigner permissions, give that role to the current user\n    const assignerRoleIds =\n      groupInfo.rolesInfo?.groupRoles\n        .filter((role) => role.can_assign_roles)\n        .map((role) => role.id) ?? [];\n    const assignerRoleFound = roleAssignments.some((roleAssignment) =>\n      assignerRoleIds.includes(roleAssignment.group_role_id),\n    );\n    if (!assignerRoleFound) {\n      if (!groupInfo.groupMembers?.some((member) => idsEqual(member.user_id, userId))) {\n        // If the current user is not in the group, this usually means they are a staff member, so give the assigner role to the first user\n        userId = groupInfo.groupMembers[0].user_id;\n      }\n      roleAssignments.push({\n        group_id: groupId,\n        user_id: userId,\n        group_role_id: assignerRoleIds[0],\n      });\n    }\n\n    await sqldb.queryAsync(sql.update_group_roles, {\n      group_id: groupId,\n      role_assignments: JSON.stringify(roleAssignments),\n      authn_user_id: authnUserId,\n    });\n  });\n}\n\nexport async function deleteGroup(assessment_id: string, group_id: string, authn_user_id: string) {\n  const deleted_group_id = await sqldb.queryOptionalRow(\n    sql.delete_group,\n    { assessment_id, group_id, authn_user_id },\n    IdSchema,\n  );\n  if (deleted_group_id == null) {\n    throw new error.HttpStatusError(404, 'Group does not exist.');\n  }\n}\n\n/**\n * Delete all groups for the given assessment.\n */\nexport async function deleteAllGroups(assessmentId: string, authnUserId: string) {\n  await sqldb.queryAsync(sql.delete_all_groups, {\n    assessment_id: assessmentId,\n    authn_user_id: authnUserId,\n  });\n}\n\nexport function getRoleNamesForUser(groupInfo: GroupInfo, user: User): string[] {\n  return groupInfo.rolesInfo?.roleAssignments[user.uid]?.map((r) => r.role_name) ?? ['None'];\n}\n"]}