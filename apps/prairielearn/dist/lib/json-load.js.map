{"version":3,"file":"json-load.js","sourceRoot":"","sources":["../../src/lib/json-load.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,MAAM,aAAa,CAAC;AAElC,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAC1B,OAAO,GAAG,MAAM,KAAK,CAAC;AAEtB,4FAA4F;AAC5F,mDAAmD;AACnD,MAAM,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;AAEtB;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,QAAQ,CAAC,YAAoB;IACjD,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,YAAY,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;IACnE,IAAI,CAAC;QACH,OAAO,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;IAC3C,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,MAAM,IAAI,KAAK,CACb,8BAA8B,YAAY,UAAU,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,OAAO,EAAE,CAC1G,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAAC,IAAY,EAAE,MAAc;IACvD,MAAM,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACrC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;IAE7B,IAAI,CAAC,KAAK,EAAE,CAAC;QACX,MAAM,IAAI,KAAK,CACb,0BAA0B,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,qBAAqB,IAAI,CAAC,SAAS,CAC1F,QAAQ,CAAC,MAAM,EACf,IAAI,EACJ,CAAC,CACF,EAAE,CACJ,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAAC,YAAoB,EAAE,MAAc;IACrE,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,YAAY,CAAC,CAAC;IAE1C,IAAI,CAAC,MAAM;QAAE,OAAO,IAAI,CAAC;IAEzB,IAAI,CAAC;QACH,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,MAAM,IAAI,KAAK,CAAC,0BAA0B,YAAY,qBAAqB,CAAC,EAAE,CAAC,CAAC;IAClF,CAAC;AACH,CAAC","sourcesContent":["import * as fs from 'fs/promises';\n\nimport { Ajv } from 'ajv';\nimport jju from 'jju';\n\n// We use a single global instance so that schemas aren't recompiled every time they're used\n// https://github.com/ajv-validator/ajv/issues/2132\nconst ajv = new Ajv();\n\n/**\n * Asynchronously reads the specified JSON file.\n *\n * @param jsonFilename The name of the file to read\n * @returns The parsed JSON\n */\nexport async function readJSON(jsonFilename: string): Promise<any> {\n  const data = await fs.readFile(jsonFilename, { encoding: 'utf8' });\n  try {\n    return jju.parse(data, { mode: 'json' });\n  } catch (e) {\n    throw new Error(\n      `Error in JSON file format: ${jsonFilename} (line ${e.row}, column ${e.column})\\n${e.name}: ${e.message}`,\n    );\n  }\n}\n\n/**\n * Validates an object with the specified JSON schema.\n *\n * @param json The object to validate\n * @param schema The schema used to validate the object\n */\nexport function validateJSON(json: object, schema: object) {\n  const validate = ajv.compile(schema);\n  const valid = validate(json);\n\n  if (!valid) {\n    throw new Error(\n      `JSON validation error: ${ajv.errorsText(validate.errors)}\\nError details:\\n${JSON.stringify(\n        validate.errors,\n        null,\n        2,\n      )}`,\n    );\n  }\n}\n\n/**\n * Reads and validates some type of `info.json` file.\n *\n * @param jsonFilename The name of the file to read\n * @param schema The name of the schema file\n * @returns The parsed and validated JSON\n */\nexport async function readInfoJSON(jsonFilename: string, schema: object): Promise<any> {\n  const json = await readJSON(jsonFilename);\n\n  if (!schema) return json;\n\n  try {\n    validateJSON(json, schema);\n    return json;\n  } catch (e) {\n    throw new Error(`Error validating file '${jsonFilename}' against schema: ${e}`);\n  }\n}\n"]}