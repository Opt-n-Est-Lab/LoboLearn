{"version":3,"file":"markdown.js","sourceRoot":"","sources":["../../src/lib/markdown.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAEzC,OAAO,EAAkB,IAAI,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AACpE,OAAO,EAAE,eAAe,EAAE,MAAM,wBAAwB,CAAC;AAEzD,8EAA8E;AAC9E,gDAAgD;AAChD,sGAAsG;AACtG,MAAM,KAAK,GAAG,gCAAgC,CAAC;AAC/C,MAAM,WAAW,GAAG,sBAAsB,CAAC;AAC3C,MAAM,SAAS,GAAG,uBAAuB,CAAC;AAE1C,SAAS,cAAc,CAAC,GAAc;IACpC,OAAO,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,CAAC,IAAU,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE;QACtD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QAC7B,MAAM,KAAK,GAAgB,EAAE,CAAC;QAE9B,MAAM,GAAG,GAAG,IAAI,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,GAAG,EAAE,CAAC;YACR,MAAM,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,cAAc,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAC9B,IAAI,QAAQ,EAAE,CAAC;gBACb,KAAK,CAAC,IAAI,CAAC,IAAI,CAAA,aAAa,QAAQ,GAAG,CAAC,CAAC;YAC3C,CAAC;YACD,IAAI,cAAc,EAAE,CAAC;gBACnB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAA,oBAAoB,cAAc,GAAG,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;QAED,MAAM,OAAO,GAAS;YACpB,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,IAAI,CAAA,YAAY,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,KAAK,YAAY,CAAC,QAAQ,EAAE;SAC5E,CAAC;QACF,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;IAClD,CAAC,CAAC,CAAC;AACL,CAAC;AAED,0EAA0E;AAC1E,gCAAgC;AAChC,MAAM,iBAAiB,GAAG,eAAe,CAAC,EAAE,aAAa,EAAE,CAAC,cAAc,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAC;AAEhG,MAAM,UAAU,eAAe,CAAC,IAAY;IAC1C,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,MAAM,EAAE,gBAAwB,EAAE,EAAE;QAC9D,8EAA8E;QAC9E,MAAM,eAAe,GAAG,gBAAgB,CAAC,OAAO,CAC9C,WAAW,EACX,CAAC,MAAM,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;YACzC,OAAO,GAAG,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;QACtD,CAAC,CACF,CAAC;QACF,MAAM,GAAG,GAAG,iBAAiB,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;QAC3D,OAAO,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;IAC9B,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { Code, Html, Root as MdastRoot } from 'mdast';\nimport { visit } from 'unist-util-visit';\n\nimport { type HtmlValue, html, joinHtml } from '@prairielearn/html';\nimport { createProcessor } from '@prairielearn/markdown';\n\n// The ? symbol is used to make the match non-greedy (i.e., match the shortest\n// possible string that fulfills the regex). See\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Quantifiers#types\nconst regex = /<markdown>(.*?)<\\/markdown>/gms;\nconst escapeRegex = /(<\\/?markdown)(#+)>/g;\nconst langRegex = /([^\\\\{]*)?(\\{(.*)\\})?/;\n\nfunction visitCodeBlock(ast: MdastRoot) {\n  return visit(ast, 'code', (node: Code, index, parent) => {\n    const { lang, value } = node;\n    const attrs: HtmlValue[] = [];\n\n    const res = lang?.match(langRegex);\n    if (res) {\n      const language = res[1];\n      const highlightLines = res[3];\n      if (language) {\n        attrs.push(html`language=\"${language}\"`);\n      }\n      if (highlightLines) {\n        attrs.push(html`highlight-lines=\"${highlightLines}\"`);\n      }\n    }\n\n    const newNode: Html = {\n      type: 'html',\n      value: html`<pl-code ${joinHtml(attrs, ' ')}>${value}</pl-code>`.toString(),\n    };\n    parent?.children.splice(index ?? 0, 1, newNode);\n  });\n}\n\n// The question processor also includes the use of pl-code instead of pre,\n// and does not sanitize scripts\nconst questionProcessor = createProcessor({ mdastVisitors: [visitCodeBlock], sanitize: false });\n\nexport function processQuestion(html: string) {\n  return html.replace(regex, (_match, originalContents: string) => {\n    // We'll handle escapes before we pass off the string to our Markdown pipeline\n    const decodedContents = originalContents.replace(\n      escapeRegex,\n      (_match, prefix: string, hashes: string) => {\n        return `${prefix}${'#'.repeat(hashes.length - 1)}>`;\n      },\n    );\n    const res = questionProcessor.processSync(decodedContents);\n    return res.value.toString();\n  });\n}\n"]}