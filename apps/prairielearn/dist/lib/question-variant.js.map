{"version":3,"file":"question-variant.js","sourceRoot":"","sources":["../../src/lib/question-variant.ts"],"names":[],"mappings":"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","sourcesContent":["import fg from 'fast-glob';\nimport { z } from 'zod';\n\nimport * as error from '@prairielearn/error';\nimport * as sqldb from '@prairielearn/postgres';\nimport { workspaceFastGlobDefaultOptions } from '@prairielearn/workspace-utils';\n\nimport { selectCourseInstanceById } from '../models/course-instances.js';\nimport { selectCourseById } from '../models/course.js';\nimport { selectQuestionById, selectQuestionByInstanceQuestionId } from '../models/question.js';\nimport * as questionServers from '../question-servers/index.js';\n\nimport { type Course, IdSchema, type Question, type Variant, VariantSchema } from './db-types.js';\nimport { idsEqual } from './id.js';\nimport { writeCourseIssues } from './issues.js';\n\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nconst VariantWithFormattedDateSchema = VariantSchema.extend({\n  formatted_date: z.string(),\n});\ntype VariantWithFormattedDate = z.infer<typeof VariantWithFormattedDateSchema>;\n\nconst InstanceQuestionDataSchema = z.object({\n  question_id: IdSchema,\n  user_id: IdSchema.nullable(),\n  group_id: IdSchema.nullable(),\n  assessment_instance_id: IdSchema,\n  course_instance_id: IdSchema,\n  instance_question_open: z.boolean().nullable(),\n  assessment_instance_open: z.boolean().nullable(),\n});\n\ninterface VariantCreationData {\n  variant_seed: string;\n  params: Record<string, any>;\n  true_answer: Record<string, any>;\n  options: Record<string, any>;\n  broken: boolean;\n}\n\n/**\n * Internal function, do not call directly. Create a variant object, do not write to DB.\n * @protected\n *\n * @param question - The question for the variant.\n * @param course - The course for the question.\n * @param options - Options controlling the creation: options = {variant_seed}\n */\nasync function makeVariant(\n  question: Question,\n  course: Course,\n  options: { variant_seed?: string | null },\n): Promise<{\n  courseIssues: (Error & { fatal?: boolean; data?: any })[];\n  variant: VariantCreationData;\n}> {\n  let variant_seed: string;\n  if (options.variant_seed != null) {\n    variant_seed = options.variant_seed;\n  } else {\n    variant_seed = Math.floor(Math.random() * Math.pow(2, 32)).toString(36);\n  }\n\n  const questionModule = questionServers.getModule(question.type);\n  const { courseIssues, data } = await questionModule.generate(question, course, variant_seed);\n  const hasFatalIssue = courseIssues.some((issue) => issue.fatal);\n  let variant: VariantCreationData = {\n    variant_seed,\n    params: data.params || {},\n    true_answer: data.true_answer || {},\n    options: data.options || {},\n    broken: hasFatalIssue,\n  };\n\n  if (question.workspace_image !== null) {\n    // if workspace, add graded files to params\n    variant.params['_workspace_required_file_names'] = (\n      question.workspace_graded_files || []\n    ).filter((file) => !fg.isDynamicPattern(file, workspaceFastGlobDefaultOptions));\n    if (!('_required_file_names' in variant.params)) {\n      variant.params['_required_file_names'] = [];\n    }\n    variant.params['_required_file_names'] = variant.params['_required_file_names'].concat(\n      variant.params['_workspace_required_file_names'],\n    );\n  }\n\n  if (!variant.broken) {\n    const { courseIssues: prepareCourseIssues, data } = await questionModule.prepare(\n      question,\n      course,\n      variant,\n    );\n    courseIssues.push(...prepareCourseIssues);\n    const hasFatalIssue = courseIssues.some((issue) => issue.fatal);\n    variant = {\n      variant_seed,\n      params: data.params || {},\n      true_answer: data.true_answer || {},\n      options: data.options || {},\n      broken: hasFatalIssue,\n    };\n  }\n\n  return { courseIssues, variant };\n}\n\n/**\n * Get a file that is generated by code.\n *\n * @param filename\n * @param variant - The variant.\n * @param question - The question for the variant.\n * @param variant_course - The course for the variant.\n * @param user_id - The current effective user.\n * @param authn_user_id - The current authenticated user.\n */\nexport async function getDynamicFile(\n  filename: string,\n  variant: Variant,\n  question: Question,\n  variant_course: Course,\n  user_id: string,\n  authn_user_id: string,\n): Promise<Buffer> {\n  const question_course = await getQuestionCourse(question, variant_course);\n  const questionModule = questionServers.getModule(question.type);\n  if (!questionModule.file) {\n    throw new Error(`Question type ${question.type} does not support file generation`);\n  }\n  const { courseIssues, data: fileData } = await questionModule.file(\n    filename,\n    variant,\n    question,\n    question_course,\n  );\n\n  const studentMessage = 'Error creating file: ' + filename;\n  const courseData = { variant, question, course: variant_course };\n  await writeCourseIssues(\n    courseIssues,\n    variant,\n    user_id,\n    authn_user_id,\n    studentMessage,\n    courseData,\n  );\n  return fileData;\n}\n\n/**\n * Internal function, do not call directly. Get a question by either question_id or instance_question_id.\n * @protected\n *\n * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.\n * @param instance_question_id - The instance question for the new variant. Can be null if question_id is provided.\n */\nasync function selectQuestion(\n  question_id: string | null,\n  instance_question_id: string | null,\n): Promise<Question> {\n  if (question_id != null) {\n    return await selectQuestionById(question_id);\n  } else if (instance_question_id != null) {\n    return await selectQuestionByInstanceQuestionId(instance_question_id);\n  } else {\n    throw new Error('question_id and instance_question_id cannot both be null');\n  }\n}\n\nasync function lockAssessmentInstanceForInstanceQuestion(\n  instance_question_id: string,\n): Promise<void> {\n  const assessment_instance_id = await sqldb.queryOptionalRow(\n    sql.select_and_lock_assessment_instance_for_instance_question,\n    { instance_question_id },\n    IdSchema,\n  );\n  if (assessment_instance_id == null) {\n    throw new error.HttpStatusError(404, 'Instance question not found');\n  }\n}\n\nasync function selectVariantForInstanceQuestion(\n  instance_question_id: string,\n  require_open: boolean,\n): Promise<VariantWithFormattedDate | null> {\n  return await sqldb.queryOptionalRow(\n    sql.select_variant_for_instance_question,\n    { instance_question_id, require_open },\n    VariantWithFormattedDateSchema,\n  );\n}\n\n/**\n * Internal function, do not call directly. Create a variant object, and write it to the DB.\n * @protected\n *\n * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.\n * @param instance_question_id - The instance question for the new variant, or null for a floating variant.\n * @param user_id - The user for the new variant.\n * @param authn_user_id - The current authenticated user.\n * @param course_instance_id - The course instance for this variant. Can be null for instructor questions.\n * @param variant_course - The course for the variant.\n * @param question_course - The course for the question.\n * @param options - Options controlling the creation: options = {variant_seed}\n * @param require_open - If true, only use an existing variant if it is open.\n * @param client_fingerprint_id - The client fingerprint for this variant.\n */\nasync function makeAndInsertVariant(\n  question_id: string | null,\n  instance_question_id: string | null,\n  user_id: string,\n  authn_user_id: string,\n  course_instance_id: string | null,\n  variant_course: Course,\n  question_course: Course,\n  options: { variant_seed?: string | null },\n  require_open: boolean,\n  client_fingerprint_id: string | null,\n): Promise<VariantWithFormattedDate> {\n  const question = await selectQuestion(question_id, instance_question_id);\n  const { courseIssues, variant: variantData } = await makeVariant(\n    question,\n    question_course,\n    options,\n  );\n\n  const variant = await sqldb.runInTransactionAsync(async () => {\n    let real_user_id: string | null = user_id;\n    let real_group_id: string | null = null;\n    let new_number: number | null = 1;\n\n    if (instance_question_id != null) {\n      await lockAssessmentInstanceForInstanceQuestion(instance_question_id);\n      const instance_question = await sqldb.queryOptionalRow(\n        sql.select_instance_question_data,\n        { instance_question_id },\n        InstanceQuestionDataSchema,\n      );\n      if (instance_question == null) {\n        throw new error.HttpStatusError(404, 'Instance question not found');\n      }\n\n      // This handles the race condition where we simultaneously start\n      // generating two variants for the same instance question. If we're the\n      // second one to try and insert a variant, just pull the existing variant\n      // back out of the database and use that instead.\n      const existing_variant = await selectVariantForInstanceQuestion(\n        instance_question_id,\n        require_open,\n      );\n      if (existing_variant != null) {\n        return existing_variant;\n      }\n\n      if (!instance_question.instance_question_open) {\n        throw new error.HttpStatusError(403, 'Instance question is not open');\n      }\n      if (!instance_question.assessment_instance_open) {\n        throw new error.HttpStatusError(403, 'Assessment instance is not open');\n      }\n\n      question_id = instance_question.question_id;\n      course_instance_id = instance_question.course_instance_id;\n      real_user_id = instance_question.user_id;\n      real_group_id = instance_question.group_id;\n\n      new_number = await sqldb.queryOptionalRow(\n        sql.next_variant_number,\n        { instance_question_id },\n        z.number().nullable(),\n      );\n    } else {\n      if (question_id == null) {\n        throw new Error(\n          'Attempt to create a variant without a question ID or instance question ID',\n        );\n      }\n      if (user_id == null) {\n        throw new Error('Attempt to create a variant without a user ID');\n      }\n\n      if (course_instance_id != null) {\n        const course_instance = await selectCourseInstanceById(course_instance_id);\n        if (!course_instance || !idsEqual(course_instance.course_id, variant_course.id)) {\n          throw new error.HttpStatusError(403, 'Course instance not found in course');\n        }\n      }\n    }\n\n    const question = await selectQuestionById(question_id);\n    let workspace_id: string | null = null;\n    if (question.workspace_image !== null) {\n      workspace_id = await sqldb.queryOptionalRow(sql.insert_workspace, IdSchema);\n    }\n\n    return await sqldb.queryRow(\n      sql.insert_variant,\n      {\n        ...variantData,\n        instance_question_id,\n        question_id,\n        course_instance_id,\n        user_id: real_user_id,\n        group_id: real_group_id,\n        number: new_number ?? 1,\n        authn_user_id,\n        workspace_id,\n        course_id: variant_course.id,\n        client_fingerprint_id,\n      },\n      VariantWithFormattedDateSchema,\n    );\n  });\n\n  const studentMessage = 'Error creating question variant';\n  const courseData = { variant, question, course: variant_course };\n  await writeCourseIssues(\n    courseIssues,\n    variant,\n    user_id,\n    authn_user_id,\n    studentMessage,\n    courseData,\n  );\n  return variant;\n}\n\n/**\n * Ensure that there is a variant for the given instance question.\n *\n * @param question_id - The question for the new variant. Can be null if instance_question_id is provided.\n * @param instance_question_id - The instance question for the new variant, or null for a floating variant.\n * @param user_id - The user for the new variant.\n * @param authn_user_id - The current authenticated user.\n * @param course_instance_id - The course instance for this variant. Can be null for instructor questions.\n * @param variant_course - The course for the variant.\n * @param question_course - The course for the question.\n * @param options - Options controlling the creation: options = {variant_seed}\n * @param require_open - If true, only use an existing variant if it is open.\n * @param client_fingerprint_id - The client fingerprint for this variant. Can be null.\n */\nexport async function ensureVariant(\n  question_id: string | null,\n  instance_question_id: string | null,\n  user_id: string,\n  authn_user_id: string,\n  course_instance_id: string | null,\n  variant_course: Course,\n  question_course: Course,\n  options: { variant_seed?: string | null },\n  require_open: boolean,\n  client_fingerprint_id: string | null,\n): Promise<VariantWithFormattedDate> {\n  if (instance_question_id != null) {\n    // See if we have a useable existing variant, otherwise make a new one. This\n    // test is also performed in makeAndInsertVariant inside a transaction to\n    // avoid race conditions, but we do it here too to avoid the\n    // generate/prepare overhead in the most common cases.\n    const variant = await selectVariantForInstanceQuestion(instance_question_id, require_open);\n    if (variant != null) {\n      return variant;\n    }\n  }\n  // if we don't have instance_question_id or if it's not open, just make a new variant\n  return await makeAndInsertVariant(\n    question_id,\n    instance_question_id,\n    user_id,\n    authn_user_id,\n    course_instance_id,\n    variant_course,\n    question_course,\n    options,\n    require_open,\n    client_fingerprint_id,\n  );\n}\n\n/**\n * Get the course associated with the question\n *\n * @param question - The question for the variant.\n * @param variant_course - The course for the variant.\n */\nexport async function getQuestionCourse(\n  question: Question,\n  variant_course: Course,\n): Promise<Course> {\n  if (question.course_id === variant_course.id) {\n    return variant_course;\n  } else {\n    return selectCourseById(question.course_id);\n  }\n}\n"]}