{"version":3,"file":"workspace.js","sourceRoot":"","sources":["../../src/lib/workspace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,IAAI,UAAU,EAAE,MAAM,IAAI,CAAC;AAC5C,OAAO,EAAE,EAAE,IAAI,MAAM,EAAE,MAAM,aAAa,CAAC;AAC3C,OAAO,EAAE,UAAU,IAAI,KAAK,EAAE,MAAM,sBAAsB,CAAC;AAC3D,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B,OAAO,QAAQ,MAAM,UAAU,CAAC;AAChC,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,OAAO,MAAM,OAAO,CAAC;AAE5B,OAAO,EAAE,MAAM,UAAU,CAAC;AAC1B,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,QAAQ,MAAM,UAAU,CAAC;AAChC,OAAO,KAAK,MAAM,YAAY,CAAC;AAE/B,OAAO,KAAK,GAAG,MAAM,aAAa,CAAC;AACnC,OAAO,EAAE,EAAE,IAAI,MAAM,EAAE,MAAM,MAAM,CAAC;AACpC,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAExB,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,uBAAuB,EAAE,MAAM,0BAA0B,CAAC;AAC7E,OAAO,KAAK,KAAK,MAAM,wBAAwB,CAAC;AAChD,OAAO,KAAK,MAAM,MAAM,sBAAsB,CAAC;AAC/C,OAAO,EAAE,gBAAgB,EAAE,MAAM,4BAA4B,CAAC;AAC9D,OAAO,KAAK,cAAc,MAAM,+BAA+B,CAAC;AAEhE,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AACtC,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AACrC,OAAO,EACL,YAAY,EACZ,iBAAiB,EACjB,cAAc,EACd,aAAa,EACb,mBAAmB,EACnB,eAAe,GAChB,MAAM,eAAe,CAAC;AACvB,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AACtC,OAAO,KAAK,YAAY,MAAM,oBAAoB,CAAC;AACnD,OAAO,KAAK,kBAAkB,MAAM,oBAAoB,CAAC;AAEzD,MAAM,KAAK,GAAG,OAAO,CAAC,wBAAwB,CAAC,CAAC;AAChD,MAAM,GAAG,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAEhD,MAAM,mBAAmB,GAAG,CAAC,CAAC,MAAM,CAAC;IACnC,SAAS,EAAE,eAAe;IAC1B,OAAO,EAAE,aAAa;IACtB,QAAQ,EAAE,cAAc;IACxB,MAAM,EAAE,YAAY;CACrB,CAAC,CAAC;AAEH,MAAM,oCAAoC,GAAG,CAAC,CAAC,MAAM,CAAC;IACpD,iBAAiB,EAAE,eAAe,CAAC,KAAK,CAAC,OAAO;IAChD,sBAAsB,EAAE,cAAc,CAAC,KAAK,CAAC,sBAAsB;CACpE,CAAC,CAAC;AAkCH;;GAEG;AACH,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAC9C,YAAY,OAAO;QACjB,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;IACtC,CAAC;CACF;AAED,MAAM,CAAC,KAAK,UAAU,IAAI;IACxB,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;IACrC,YAAY,CAAC,EAAE;SACZ,EAAE,CAAC,cAAc,CAAC,0BAA0B,CAAC;SAC7C,GAAG,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;QACpB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACxC,IAAI,CAAC,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAAC;YAC5C,OAAO;QACT,CAAC;QAED,IACE,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK;YAC5B,CAAC,gBAAgB,CACf,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAC3B,EAAE,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,EAAE,EACpD,MAAM,CAAC,SAAS,CACjB,EACD,CAAC;YACD,IAAI,CAAC,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;YACjC,OAAO;QACT,CAAC;QAED,IAAI,EAAE,CAAC;IACT,CAAC,CAAC;SACD,EAAE,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;AAClC,CAAC;AAED;;GAEG;AACH,SAAS,UAAU,CAAC,MAAc;IAChC,yEAAyE;IACzE,yEAAyE;IACzE,MAAM,YAAY,GAAG,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC;IAExD,MAAM,CAAC,EAAE,CAAC,eAAe,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE;QACrC,8EAA8E;QAC9E,sEAAsE;QACtE,MAAM,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAE7B,MAAM,CAAC,IAAI,CAAC,aAAa,YAAY,EAAE,CAAC,CAAC;QAEzC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,EAAE,EAAE,YAAY,EAAE,EAAE,eAAe,CAAC,CAAC,IAAI,CAC1E,CAAC,SAAS,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,YAAY,EAAE,KAAK,EAAE,SAAS,CAAC,KAAK,EAAE,CAAC,EACjE,CAAC,GAAG,EAAE,EAAE;YACN,QAAQ,CAAC,EAAE,YAAY,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YACxC,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC,CACF,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,EAAE,CAAC,gBAAgB,EAAE,GAAG,EAAE;QAC/B,OAAO,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;YACxC,MAAM,CAAC,KAAK,CAAC,4BAA4B,YAAY,EAAE,EAAE,GAAG,CAAC,CAAC;YAC9D,MAAM,cAAc,CAAC,oBAAoB,CACvC,YAAY,EACZ,SAAS,EACT,+CAA+C,GAAG,EAAE,CACrD,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE;QACjC,8EAA8E;QAC9E,sEAAsE;QACtE,MAAM,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAE7B,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,iCAAiC,EAAE,EAAE,YAAY,EAAE,EAAE,iBAAiB,CAAC,CAAC,IAAI,CAC7F,CAAC,YAAY,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,YAAY,EAAE,YAAY,EAAE,CAAC,EAC1D,CAAC,GAAG,EAAE,EAAE;YACN,QAAQ,CAAC,EAAE,YAAY,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YACxC,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC,CACF,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAQD,KAAK,UAAU,gBAAgB,CAC7B,YAAoB,EACpB,MAAiC,EACjC,OAAO,GAAG,EAAE;IAEZ,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,gBAAgB,CACjD,GAAG,CAAC,qBAAqB,EACzB,EAAE,YAAY,EAAE,EAChB,mBAAmB,CACpB,CAAC;IACF,IAAI,cAAc,IAAI,IAAI,EAAE,CAAC;QAC3B,MAAM,IAAI,KAAK,CAAC,4BAA4B,YAAY,EAAE,CAAC,CAAC;IAC9D,CAAC;IACD,IAAI,CAAC,MAAM,CAAC,eAAe;QAAE,OAAO;IAEpC,MAAM,QAAQ,GAAG,EAAE,YAAY,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC;IACnD,MAAM,GAAG,GAAG,MAAM,KAAK,CAAC,UAAU,cAAc,CAAC,QAAQ,GAAG,EAAE;QAC5D,MAAM,EAAE,MAAM;QACd,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;QAC9B,OAAO,EAAE,EAAE,cAAc,EAAE,kBAAkB,EAAE;KAChD,CAAC,CAAC;IAEH,IAAI,MAAM,KAAK,gBAAgB,EAAE,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;YACZ,MAAM,IAAI,qBAAqB,CAAE,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE,CAAS,CAAC,OAAO,CAAC,CAAC;QACvE,CAAC;QAED,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,IAAI,qBAAqB,CAAC,kBAAkB,CAAC,CAAC;QACtD,CAAC;QAED,MAAM,kBAAkB,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC;QAClE,IAAI,kBAAkB,IAAI,IAAI;YAAE,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;QAC/E,MAAM,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;QACxE,IAAI,CAAC,KAAK;YAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,kBAAkB,EAAE,CAAC,CAAC;QACvF,MAAM,OAAO,GAAG,MAAM,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;QAEvD,KAAK,CAAC,4BAA4B,OAAO,EAAE,CAAC,CAAC;QAC7C,MAAM,MAAM,GAAG,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAE7C,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM;iBACH,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE;gBACf,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpB,CAAC,CAAC;iBACD,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE;gBACnB,MAAM,CAAC,GAAG,CAAC,CAAC;YACd,CAAC,CAAC;iBACD,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;gBACjB,OAAO,CAAC,OAAO,CAAC,CAAC;YACnB,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAI,GAAG,CAAC,EAAE;QAAE,OAAO;IAEnB,uEAAuE;IACvE,MAAM,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE,CAAQ,CAAC;IACvC,MAAM,IAAI,KAAK,CAAC,8BAA8B,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;AAChE,CAAC;AAED,KAAK,UAAU,OAAO,CAAC,YAAoB;IACzC,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,EAAE,EAAE,YAAY,EAAE,EAAE,eAAe,CAAC,CAAC;IAC7F,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAE3B,IAAI,KAAK,KAAK,eAAe,IAAI,KAAK,KAAK,SAAS;QAAE,OAAO;IAE7D,MAAM,aAAa,GAAG,KAAK,KAAK,eAAe,CAAC;IAEhD,IAAI,gBAAgB,GAA4B,IAAI,CAAC;IACrD,IAAI,KAAK,KAAK,eAAe,EAAE,CAAC;QAC9B,gBAAgB,GAAG,MAAM,UAAU,CAAC,YAAY,CAAC,CAAC;IACpD,CAAC;IAED,qEAAqE;IACrE,iEAAiE;IACjE,mEAAmE;IACnE,yEAAyE;IACzE,kBAAkB;IAClB,EAAE;IACF,kEAAkE;IAClE,iDAAiD;IACjD,sEAAsE;IACtE,gCAAgC;IAChC,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAC7B,MAAM,KAAK,CAAC,qBAAqB,CAAC,KAAK,IAAI,EAAE;QAC3C,iCAAiC;QACjC,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,QAAQ,CACpC,GAAG,CAAC,yBAAyB,EAC7B,EAAE,YAAY,EAAE,EAChB,eAAe,CAChB,CAAC;QAEF,oEAAoE;QACpE,wEAAwE;QACxE,MAAM,yBAAyB,GAC7B,KAAK,KAAK,eAAe,IAAI,SAAS,CAAC,KAAK,KAAK,eAAe,CAAC;QACnE,IAAI,yBAAyB,EAAE,CAAC;YAC9B,IAAI,gBAAgB,KAAK,IAAI,EAAE,CAAC;gBAC9B,+EAA+E;gBAC/E,mEAAmE;gBACnE,uEAAuE;gBACvE,qEAAqE;gBACrE,qEAAqE;gBACrE,sEAAsE;gBACtE,qCAAqC;gBACrC,IAAI,CAAC;oBACH,MAAM,eAAe,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,eAAe,EAAE,GAAG,CAAC,CAAC;oBAC/E,MAAM,EAAE,CAAC,IAAI,CACX,gBAAgB,CAAC,eAAe,EAChC,GAAG,gBAAgB,CAAC,eAAe,QAAQ,eAAe,EAAE,EAC5D,EAAE,SAAS,EAAE,IAAI,EAAE,CACpB,CAAC;gBACJ,CAAC;gBAAC,OAAO,GAAG,EAAE,CAAC;oBACb,gFAAgF;oBAChF,6BAA6B;oBAC7B,IAAI,GAAG,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;wBAC1B,MAAM,GAAG,CAAC;oBACZ,CAAC;gBACH,CAAC;gBAED,kEAAkE;gBAClE,qEAAqE;gBACrE,0DAA0D;gBAC1D,MAAM,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,gBAAgB,CAAC,eAAe,EAAE;oBAC3E,SAAS,EAAE,IAAI;iBAChB,CAAC,CAAC;YACL,CAAC;YACD,MAAM,cAAc,CAAC,oBAAoB,CAAC,YAAY,EAAE,SAAS,EAAE,yBAAyB,CAAC,CAAC;QAChG,CAAC;QAED,4EAA4E;QAC5E,qCAAqC;QACrC,IAAI,SAAS,CAAC,KAAK,KAAK,SAAS,IAAI,yBAAyB,EAAE,CAAC;YAC/D,MAAM,cAAc,CAAC,oBAAoB,CACvC,YAAY,EACZ,WAAW,EACX,0BAA0B,CAC3B,CAAC;YACF,gBAAgB,GAAG,IAAI,CAAC;QAC1B,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,qEAAqE;IACrE,qDAAqD;IACrD,IAAI,CAAC,gBAAgB;QAAE,OAAO;IAE9B,IAAI,iBAAiB,GAAkB,IAAI,CAAC;IAC5C,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,iDAAiD;IACjD,OAAO,IAAI,EAAE,CAAC;QACZ,IAAI,OAAO,GAAG,MAAM,CAAC,+BAA+B,EAAE,CAAC;YACrD,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;QAC1E,CAAC;QACD,iBAAiB,GAAG,MAAM,UAAU,CAAC,YAAY,CAAC,CAAC;QACnD,IAAI,iBAAiB,IAAI,IAAI,EAAE,CAAC;YAC9B,MAAM,CAAC,yBAAyB;QAClC,CAAC;QACD,MAAM,CAAC,GAAG,OAAO,GAAG,MAAM,CAAC,kCAAkC,CAAC;QAC9D,MAAM,cAAc,CAAC,sBAAsB,CACzC,YAAY,EACZ,2CAA2C,CAAC,mBAAmB,CAChE,CAAC;QACF,MAAM,KAAK,CAAC,MAAM,CAAC,kCAAkC,GAAG,IAAI,CAAC,CAAC;QAC9D,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,MAAM,cAAc,CAAC,sBAAsB,CAAC,YAAY,EAAE,gCAAgC,CAAC,CAAC;IAC5F,MAAM,gBAAgB,CAAC,YAAY,EAAE,MAAM,EAAE,EAAE,aAAa,EAAE,CAAC,CAAC;AAClE,CAAC;AAED;;;;;;;;;;GAUG;AACH,KAAK,UAAU,UAAU,CAAC,YAAoB;IAC5C,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,MAAM,KAAK,CAAC,QAAQ,CACnE,GAAG,CAAC,qBAAqB,EACzB,EAAE,YAAY,EAAE,EAChB,mBAAmB,CACpB,CAAC;IAEF,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,aAAa,YAAY,8CAA8C,CAAC,CAAC;IAE9F,MAAM,WAAW,GAAG,MAAM,CAAC,4BAA4B,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;IAC9F,MAAM,MAAM,CAAC,0BAA0B,CAAC,MAAM,CAAC,EAAE,EAAE;QACjD,IAAI,EAAE,UAAU;QAChB,UAAU,EAAE,QAAQ,CAAC,EAAE;KACxB,CAAC,CAAC;IAEH,wBAAwB;IACxB,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC;IAC3E,MAAM,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,mBAAmB,CAAC,CAAC;IAE1E,wDAAwD;IACxD,MAAM,aAAa,GAAG,aAAa,YAAY,IAAI,SAAS,CAAC,OAAO,EAAE,CAAC;IACvE,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;IAEvD,MAAM,IAAI,GAAG,MAAM,CAAC,oBAAoB,CAAC;IACzC,MAAM,eAAe,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IACpD,MAAM,UAAU,GAAG,GAAG,eAAe,IAAI,MAAM,EAAE,EAAE,CAAC;IAEpD,MAAM,EAAE,oBAAoB,EAAE,GAAG,MAAM,sBAAsB,CAAC;QAC5D,qBAAqB;QACrB,gBAAgB;QAChB,MAAM,EAAE,OAAO,CAAC,MAAM;QACtB,cAAc,EAAE,OAAO,CAAC,WAAW;QACnC,UAAU,EAAE,UAAU;KACvB,CAAC,CAAC;IAEH,4FAA4F;IAC5F,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;QAC1C,MAAM,UAAU,CAAC,KAAK,CACpB,IAAI,CAAC,IAAI,EACT,MAAM,CAAC,8BAA8B,EACrC,MAAM,CAAC,8BAA8B,CACtC,CAAC;IACJ,CAAC;IAED,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACpC,MAAM,MAAM,GAAG,oBAAoB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7F,MAAM,MAAM,CAAC,WAAW,CAAC;YACvB,SAAS,EAAE,OAAO,CAAC,EAAE;YACrB,cAAc,EAAE,oCAAoC;YACpD,iBAAiB,EAAE,oCAAoC;YACvD,gBAAgB,EAAE,KAAK;YACvB,YAAY,EAAE,IAAI;YAClB,UAAU,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;YACpD,UAAU,EAAE;gBACV,aAAa,EAAE;oBACb,gDAAgD;oBAChD,UAAU,EAAE,MAAM;oBAClB,gEAAgE;oBAChE,MAAM,EAAE,oBAAoB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;wBAC3C,GAAG,KAAK;wBACR,yEAAyE;wBACzE,GAAG,EAAE,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC;qBAC/B,CAAC,CAAC;iBACJ;aACF;YACD,MAAM,EAAE,IAAI;YACZ,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;IACL,CAAC;IAED,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,CAAC;AACzC,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,sBAAsB,CAAC,EAC3C,qBAAqB,EACrB,gBAAgB,EAChB,MAAM,EACN,cAAc,EACd,UAAU,GAOX;IACC,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;IAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,oBAAoB,CAAC,CAAC;IAEvE,MAAM,oBAAoB,GAA0B,EAAE,CAAC;IAEvD,MAAM,WAAW,GAAoB,CACnC,MAAM,KAAK;SACR,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,IAAe,EAAiC,EAAE;QACnF,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACxB,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE;YACrE,CAAC,CAAC,IAAI,CAAC;IACX,CAAC,CAAC;SACD,KAAK,CAAC,GAAG,EAAE;QACV,uDAAuD;QACvD,OAAO,EAA8B,CAAC;IACxC,CAAC,CAAC,CACL,CAAC,MAAM,CAAC,CAAC,IAAI,EAAyB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IAElD,MAAM,cAAc,GAAG,EAAE,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,CAAC;IAEnE,MAAM,aAAa,GAAoB,CACrC,MAAM,KAAK;SACR,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,IAAe,EAAiC,EAAE;QACtF,MAAM,iBAAiB,GAAG,IAAI,CAAC,QAAQ,CACrC,YAAY,EACZ,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CACtC,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBAAE,OAAO,IAAI,CAAC;YACtC,OAAO;gBACL,IAAI,EAAE,iBAAiB;gBACvB,MAAM,EAAE,QAAQ,CAAC,MAAM,CACrB,MAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,EAC3D,cAAc,CACf;aACF,CAAC;QACJ,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,oBAAoB,CAAC,IAAI,CAAC;gBACxB,IAAI,EAAE,iBAAiB;gBACvB,GAAG;gBACH,GAAG,EAAE,4CAA4C,GAAG,CAAC,OAAO,EAAE;aAC/D,CAAC,CAAC;YACH,qDAAqD;YACrD,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;QAC3D,CAAC;IACH,CAAC,CAAC;SACD,KAAK,CAAC,GAAG,EAAE;QACV,qEAAqE;QACrE,OAAO,EAA8B,CAAC;IACxC,CAAC,CAAC,CACL,CAAC,MAAM,CAAC,CAAC,IAAI,EAAyB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IAElD,MAAM,YAAY,GACf,MAAM,EAAE,gBAAkD;QACzD,EAAE,GAAG,CAAC,CAAC,IAA0B,EAAE,CAAS,EAAwB,EAAE;QACpE,8BAA8B;QAC9B,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC;YAChB,oBAAoB,CAAC,IAAI,CAAC;gBACxB,IAAI,EAAE,gBAAgB,CAAC,EAAE;gBACzB,GAAG,EAAE,+DAA+D;gBACpE,IAAI,EAAE,IAAI;aACX,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC;QACD,IAAI,CAAC;YACH,oEAAoE;YACpE,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC;gBAC/C,oBAAoB,CAAC,IAAI,CAAC;oBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,GAAG,EAAE,yHAAyH;oBAC9H,IAAI,EAAE,IAAI;iBACX,CAAC,CAAC;gBACH,OAAO,IAAI,CAAC;YACd,CAAC;YACD,MAAM,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAErD,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;gBACpD,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,qBAAqB,CAAC;gBAC9E,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CACzB,QAAQ,EACR,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,qBAAqB,IAAI,EAAE,CACtD,CAAC;gBACF,8DAA8D;gBAC9D,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,CAAC;oBAC1C,oBAAoB,CAAC,IAAI,CAAC;wBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;wBACf,GAAG,EAAE,6DAA6D,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,mBAAmB,2BAA2B;wBACjJ,IAAI,EAAE,IAAI;qBACX,CAAC,CAAC;oBACH,OAAO,IAAI,CAAC;gBACd,CAAC;gBACD,iFAAiF;gBACjF,oCAAoC;gBACpC,OAAO;oBACL,IAAI,EAAE,kBAAkB;oBACxB,SAAS;iBACV,CAAC;YACJ,CAAC;YAED,kEAAkE;YAClE,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACzE,oBAAoB,CAAC,IAAI,CAAC;oBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,GAAG,EAAE,yDAAyD,IAAI,CAAC,QAAQ,kBAAkB;oBAC7F,IAAI,EAAE,IAAI;iBACX,CAAC,CAAC;gBACH,OAAO,IAAI,CAAC;YACd,CAAC;YAED,IAAI,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC,EAAE,CAAC;gBAC1B,oBAAoB,CAAC,IAAI,CAAC;oBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,GAAG,EAAE,mHAAmH;oBACxH,IAAI,EAAE,IAAI;iBACX,CAAC,CAAC;YACL,CAAC;YAED,OAAO;gBACL,IAAI,EAAE,kBAAkB;gBACxB,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,EAAE,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC;aACnE,CAAC;QACJ,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,4DAA4D;YAC5D,oBAAoB,CAAC,IAAI,CAAC;gBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,GAAG,EAAE,0CAA0C,GAAG,CAAC,OAAO,EAAE;gBAC5D,GAAG;gBACH,IAAI,EAAE,IAAI;aACX,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC,CAAC;SACD,MAAM,CAAC,CAAC,IAAI,EAAyB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IAE3D,MAAM,iBAAiB,GAAG,WAAW,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;IAEjF,MAAM,EAAE,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;IAE/B,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACjC,MAAM,KAAK,CAAC,UAAU,CAAC,iBAAiB,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE;YAChE,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;YAC7D,IAAI,CAAC;gBACH,MAAM,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC7C,IAAI,WAAW,IAAI,aAAa,EAAE,CAAC;oBACjC,MAAM,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;gBACrD,CAAC;qBAAM,CAAC;oBACN,MAAM,EAAE,CAAC,SAAS,CAAC,UAAU,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;gBACvD,CAAC;YACH,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,oBAAoB,CAAC,IAAI,CAAC;oBACxB,IAAI,EAAE,aAAa,CAAC,IAAI;oBACxB,GAAG,EAAE,qDAAqD,GAAG,CAAC,OAAO,EAAE;oBACvE,GAAG;oBACH,IAAI,EAAE,EAAE,aAAa,EAAE;iBACxB,CAAC,CAAC;gBACH,KAAK,CAAC,QAAQ,aAAa,CAAC,IAAI,uBAAuB,EAAE,GAAG,CAAC,CAAC;YAChE,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,EAAE,oBAAoB,EAAE,CAAC;AAClC,CAAC;AAED;;GAEG;AACH,KAAK,UAAU,UAAU,CAAC,YAAoB;IAC5C,IAAI,CAAC,MAAM,CAAC,eAAe;QAAE,OAAO,IAAI,CAAC;IAEzC,MAAM,eAAe,GAAG,MAAM,kBAAkB,CAAC,qBAAqB,CACpE,YAAY,EACZ,MAAM,CAAC,yBAAyB,CACjC,CAAC;IACF,KAAK,CAAC,8BAA8B,YAAY,uBAAuB,eAAe,EAAE,CAAC,CAAC;IAC1F,OAAO,eAAe,CAAC,CAAC,qCAAqC;AAC/D,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,cAAc,CAAC,YAAoB;IACvD,IAAI,OAAO,GAAkB,IAAI,CAAC;IAClC,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,EAAE,EAAE,YAAY,EAAE,EAAE,eAAe,CAAC,CAAC;IAEhG,IAAI,SAAS,CAAC,KAAK,KAAK,eAAe,EAAE,CAAC;QACxC,yBAAyB;QACzB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,SAAS,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;QAClC,mDAAmD;QACnD,IAAI,CAAC;YACH,OAAO,GAAG,MAAM,gBAAgB,CAAC,YAAY,EAAE,gBAAgB,CAAC,CAAC;QACnE,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,MAAM,CAAC,KAAK,CAAC,2CAA2C,EAAE,GAAG,CAAC,CAAC;YAC/D,IAAI,GAAG,YAAY,qBAAqB;gBAAE,MAAM,GAAG,CAAC;QACtD,CAAC;IACH,CAAC;IAED,uFAAuF;IACvF,IAAI,OAAO,IAAI,IAAI,EAAE,CAAC;QACpB,OAAO,GAAG,MAAM,4BAA4B,CAAC,YAAY,CAAC,CAAC;IAC7D,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,KAAK,UAAU,4BAA4B,CAAC,YAAoB;IAC9D,MAAM,EAAE,iBAAiB,EAAE,sBAAsB,EAAE,GAAG,MAAM,KAAK,CAAC,QAAQ,CACxE,GAAG,CAAC,yCAAyC,EAC7C,EAAE,YAAY,EAAE,EAChB,oCAAoC,CACrC,CAAC;IACF,MAAM,OAAO,GAAG,MAAM,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;IAEvD,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChC,MAAM,UAAU,GAAG,aAAa,YAAY,IAAI,iBAAiB,EAAE,CAAC;IACpE,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;IAEhF,IAAI,WAAoB,CAAC;IACzB,IAAI,CAAC;QACH,WAAW,GAAG,MAAM,cAAc,CAAC,uBAAuB,CACxD,SAAS,EACT,sBAAsB,IAAI,EAAE,EAC5B;YACE,QAAQ,EAAE,MAAM,CAAC,4BAA4B;YAC7C,OAAO,EAAE,MAAM,CAAC,2BAA2B;SAC5C,CACF,CAAC;IACJ,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,iFAAiF;QACjF,MAAM,IAAI,qBAAqB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC;IAED,wCAAwC;IACxC,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACnC,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACnD,KAAK,CAAC,uBAAuB,UAAU,SAAS,OAAO,EAAE,CAAC,CAAC;QAC3D,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH,yBAAyB;IACzB,MAAM,MAAM,GAAG,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAC7C,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACpC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QAE1C,MAAM;aACH,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aACjC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;YACjB,KAAK,CAAC,0BAA0B,OAAO,KAAK,OAAO,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;YAC9E,OAAO,CAAC,OAAO,CAAC,CAAC;QACnB,CAAC,CAAC,CAAC;QAEL,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACrB,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;IACjD,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,cAAc,CACrB,GAAmD;IAEnD,IAAI,GAAG,IAAI,IAAI;QAAE,OAAO,GAAG,CAAC;IAC5B,OAAO;QACL,GAAG,GAAG;QACN,KAAK,EAAE,GAAG,CAAC,KAAK;QAChB,IAAI,EAAE,GAAG,CAAC,IAAI;QACd,OAAO,EAAE,GAAG,CAAC,OAAO;QACpB,KAAK,EAAE,GAAG,CAAC,KAAK;KACjB,CAAC;AACJ,CAAC","sourcesContent":["import { promises as fsPromises } from 'fs';\nimport { ok as assert } from 'node:assert';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport * as path from 'path';\n\nimport archiver from 'archiver';\nimport * as async from 'async';\nimport debugfn from 'debug';\nimport type { Entry } from 'fast-glob';\nimport fs from 'fs-extra';\nimport klaw from 'klaw';\nimport mustache from 'mustache';\nimport fetch from 'node-fetch';\nimport type { Socket } from 'socket.io';\nimport * as tmp from 'tmp-promise';\nimport { v4 as uuidv4 } from 'uuid';\nimport { z } from 'zod';\n\nimport { logger } from '@prairielearn/logger';\nimport { contains, isContainedRelativePath } from '@prairielearn/path-utils';\nimport * as sqldb from '@prairielearn/postgres';\nimport * as Sentry from '@prairielearn/sentry';\nimport { checkSignedToken } from '@prairielearn/signed-token';\nimport * as workspaceUtils from '@prairielearn/workspace-utils';\n\nimport * as chunks from './chunks.js';\nimport { config } from './config.js';\nimport {\n  CourseSchema,\n  DateFromISOString,\n  QuestionSchema,\n  VariantSchema,\n  WorkspaceHostSchema,\n  WorkspaceSchema,\n} from './db-types.js';\nimport * as issues from './issues.js';\nimport * as socketServer from './socket-server.js';\nimport * as workspaceHostUtils from './workspaceHost.js';\n\nconst debug = debugfn('prairielearn:workspace');\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nconst WorkspaceDataSchema = z.object({\n  workspace: WorkspaceSchema,\n  variant: VariantSchema,\n  question: QuestionSchema,\n  course: CourseSchema,\n});\n\nconst WorkspaceVersionAndGradedFilesSchema = z.object({\n  workspace_version: WorkspaceSchema.shape.version,\n  workspace_graded_files: QuestionSchema.shape.workspace_graded_files,\n});\n\ninterface DiskWorkspaceFile {\n  name: string;\n  localPath: string;\n}\n\ninterface BufferWorkspaceFile {\n  name: string;\n  buffer: Buffer | string;\n}\n\ntype WorkspaceFile = DiskWorkspaceFile | BufferWorkspaceFile;\n\ninterface DynamicWorkspaceFile {\n  name?: string;\n  contents?: string;\n  encoding?: BufferEncoding;\n  questionFile?: string;\n  serverFilesCourseFile?: string;\n}\n\ninterface InitializeResult {\n  sourcePath: string;\n  destinationPath: string;\n}\n\ninterface FileGenerationError {\n  file: string;\n  msg: string;\n  err?: any;\n  data?: Record<string, any>;\n}\n\n/**\n * Internal error type for tracking submission with format issues.\n */\nexport class SubmissionFormatError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'SubmissionFormatError';\n  }\n}\n\nexport async function init(): Promise<void> {\n  workspaceUtils.init(socketServer.io);\n  socketServer.io\n    .of(workspaceUtils.WORKSPACE_SOCKET_NAMESPACE)\n    .use((socket, next) => {\n      if (!socket.handshake.auth.workspace_id) {\n        next(new Error('No workspace_id provided'));\n        return;\n      }\n\n      if (\n        !socket.handshake.auth.token ||\n        !checkSignedToken(\n          socket.handshake.auth.token,\n          { workspace_id: socket.handshake.auth.workspace_id },\n          config.secretKey,\n        )\n      ) {\n        next(new Error('Invalid token'));\n        return;\n      }\n\n      next();\n    })\n    .on('connection', connection);\n}\n\n/**\n * Called when a client connects to the workspace namespace.\n */\nfunction connection(socket: Socket) {\n  // The middleware will have already ensured that this property exists and\n  // that the client possesses a token that is valid for this workspace ID.\n  const workspace_id = socket.handshake.auth.workspace_id;\n\n  socket.on('joinWorkspace', (...args) => {\n    // Forwards compatibility with clients who may no longer be sending a message.\n    // TODO: remove this in the future once all clients have been updated.\n    const callback = args.at(-1);\n\n    socket.join(`workspace-${workspace_id}`);\n\n    sqldb.queryRow(sql.select_workspace, { workspace_id }, WorkspaceSchema).then(\n      (workspace) => callback({ workspace_id, state: workspace.state }),\n      (err) => {\n        callback({ errorMessage: err.message });\n        Sentry.captureException(err);\n      },\n    );\n  });\n\n  socket.on('startWorkspace', () => {\n    startup(workspace_id).catch(async (err) => {\n      logger.error(`Error starting workspace ${workspace_id}`, err);\n      await workspaceUtils.updateWorkspaceState(\n        workspace_id,\n        'stopped',\n        `Error! Click \"Reboot\" to try again. Detail: ${err}`,\n      );\n    });\n  });\n\n  socket.on('heartbeat', (...args) => {\n    // Forwards compatibility with clients who may no longer be sending a message.\n    // TODO: remove this in the future once all clients have been updated.\n    const callback = args.at(-1);\n\n    sqldb.queryRow(sql.update_workspace_heartbeat_at_now, { workspace_id }, DateFromISOString).then(\n      (heartbeat_at) => callback({ workspace_id, heartbeat_at }),\n      (err) => {\n        callback({ errorMessage: err.message });\n        Sentry.captureException(err);\n      },\n    );\n  });\n}\n\nasync function controlContainer(workspace_id: string, action: 'getGradedFiles'): Promise<string>;\nasync function controlContainer(\n  workspace_id: string,\n  action: 'init',\n  options: { useInitialZip: boolean },\n): Promise<void>;\nasync function controlContainer(\n  workspace_id: string,\n  action: 'init' | 'getGradedFiles',\n  options = {},\n): Promise<any> {\n  const workspace_host = await sqldb.queryOptionalRow(\n    sql.select_workspace_host,\n    { workspace_id },\n    WorkspaceHostSchema,\n  );\n  if (workspace_host == null) {\n    throw new Error(`No host for workspace_id=${workspace_id}`);\n  }\n  if (!config.workspaceEnable) return;\n\n  const postJson = { workspace_id, action, options };\n  const res = await fetch(`http://${workspace_host.hostname}/`, {\n    method: 'post',\n    body: JSON.stringify(postJson),\n    headers: { 'Content-Type': 'application/json' },\n  });\n\n  if (action === 'getGradedFiles') {\n    if (!res.ok) {\n      throw new SubmissionFormatError(((await res.json()) as any).message);\n    }\n\n    const body = res.body;\n    if (!body) {\n      throw new SubmissionFormatError('No response body');\n    }\n\n    const contentDisposition = res.headers.get('content-disposition');\n    if (contentDisposition == null) throw new Error('Content-Disposition is null');\n    const match = contentDisposition.match(/^attachment; filename=\"(.*)\"$/);\n    if (!match) throw new Error(`Content-Disposition format error: ${contentDisposition}`);\n    const zipPath = await tmp.tmpName({ postfix: '.zip' });\n\n    debug(`controlContainer: saving ${zipPath}`);\n    const stream = fs.createWriteStream(zipPath);\n\n    return new Promise((resolve, reject) => {\n      stream\n        .on('open', () => {\n          body.pipe(stream);\n        })\n        .on('error', (err) => {\n          reject(err);\n        })\n        .on('finish', () => {\n          resolve(zipPath);\n        });\n    });\n  }\n\n  if (res.ok) return;\n\n  // if there was an error, we should have an error message from the host\n  const json = (await res.json()) as any;\n  throw new Error(`Error from workspace host: ${json.message}`);\n}\n\nasync function startup(workspace_id: string): Promise<void> {\n  const result = await sqldb.queryRow(sql.select_workspace, { workspace_id }, WorkspaceSchema);\n  const state = result.state;\n\n  if (state !== 'uninitialized' && state !== 'stopped') return;\n\n  const useInitialZip = state === 'uninitialized';\n\n  let initializeResult: InitializeResult | null = null;\n  if (state === 'uninitialized') {\n    initializeResult = await initialize(workspace_id);\n  }\n\n  // We don't lock the above call to `initialize()` because it contains\n  // a fair amount of I/O and we don't want to hold a lock during a\n  // potentially long operation. However, we will lock here to ensure\n  // that we don't run into problems if `startup()` was called concurrently\n  // somewhere else:\n  //\n  // - We don't want an interleaving of state transitions like this:\n  //   stopped -> launching -> stopped -> launching\n  // - We don't want multiple hosts trying to assign a host for the same\n  //   workspace at the same time.\n  let shouldAssignHost = false;\n  await sqldb.runInTransactionAsync(async () => {\n    // First, lock the workspace row.\n    const workspace = await sqldb.queryRow(\n      sql.select_and_lock_workspace,\n      { workspace_id },\n      WorkspaceSchema,\n    );\n\n    // If the initial state was `uninitialized`, we should check if it's\n    // still uninitialized. If so, we'll need to perform a state transition.\n    const shouldTransitionToStopped =\n      state === 'uninitialized' && workspace.state === 'uninitialized';\n    if (shouldTransitionToStopped) {\n      if (initializeResult !== null) {\n        // First, move any existing directory out of the way to get a clean start. This\n        // should never happen in production environments, but when running\n        // workspaces locally in development, we may end up trying to reuse the\n        // same workspace ID and thus directory, for instance if the database\n        // is reset in the middle of testing. In that case, we want to ensure\n        // that we don't try to write on top of an existing directory, as this\n        // could lead to unexpected behavior.\n        try {\n          const timestampSuffix = new Date().toISOString().replace(/[^a-zA-Z0-9]/g, '-');\n          await fs.move(\n            initializeResult.destinationPath,\n            `${initializeResult.destinationPath}-bak-${timestampSuffix}`,\n            { overwrite: true },\n          );\n        } catch (err) {\n          // If the directory couldn't be moved because it didn't exist, ignore the error.\n          // But otherwise, rethrow it.\n          if (err.code !== 'ENOENT') {\n            throw err;\n          }\n        }\n\n        // Next, move the newly created directory into place. This will be\n        // done with a lock held, so we shouldn't worry about other processes\n        // trying to work with these directories at the same time.\n        await fs.move(initializeResult.sourcePath, initializeResult.destinationPath, {\n          overwrite: true,\n        });\n      }\n      await workspaceUtils.updateWorkspaceState(workspace_id, 'stopped', 'Initialization complete');\n    }\n\n    // If the workspace is in the stopped state (or we just transitioned to it),\n    // transition to the launching state.\n    if (workspace.state === 'stopped' || shouldTransitionToStopped) {\n      await workspaceUtils.updateWorkspaceState(\n        workspace_id,\n        'launching',\n        'Assigning workspace host',\n      );\n      shouldAssignHost = true;\n    }\n  });\n\n  // Bail out if needed; this should only ever occur if another host is\n  // already trying to assign this host to a workspace.\n  if (!shouldAssignHost) return;\n\n  let workspace_host_id: string | null = null;\n  let attempt = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (attempt > config.workspaceLaunchingRetryAttempts) {\n      throw new Error('Time exceeded to deploy more computational resources');\n    }\n    workspace_host_id = await assignHost(workspace_id);\n    if (workspace_host_id != null) {\n      break; // success, we got a host\n    }\n    const t = attempt * config.workspaceLaunchingRetryIntervalSec;\n    await workspaceUtils.updateWorkspaceMessage(\n      workspace_id,\n      `Deploying more computational resources (${t} seconds elapsed)`,\n    );\n    await sleep(config.workspaceLaunchingRetryIntervalSec * 1000);\n    attempt++;\n  }\n  await workspaceUtils.updateWorkspaceMessage(workspace_id, 'Sending launch command to host');\n  await controlContainer(workspace_id, 'init', { useInitialZip });\n}\n\n/**\n * This function constructs the initial state of a workspace.\n *\n * We'll construct the initial directory on disk in a temporary location and\n * then return the path to that directory, as well as the path that the\n * directory should be moved to. The caller is responsible for obtaining a\n * lock for this workspace and moving the directory into its final location.\n * Locking ensures that multiple hosts can't clobber writes to the same\n * workspace. This is mostly important on NFS volumes, where renames (moves)\n * are not atomic.\n */\nasync function initialize(workspace_id: string): Promise<InitializeResult> {\n  const { workspace, variant, question, course } = await sqldb.queryRow(\n    sql.select_workspace_data,\n    { workspace_id },\n    WorkspaceDataSchema,\n  );\n\n  assert(question.qid, `Workspace ${workspace_id} is part of a question that has no directory`);\n\n  const course_path = chunks.getRuntimeDirectoryForCourse({ id: course.id, path: course.path });\n  await chunks.ensureChunksForCourseAsync(course.id, {\n    type: 'question',\n    questionId: question.id,\n  });\n\n  // local workspace files\n  const questionBasePath = path.join(course_path, 'questions', question.qid);\n  const serverFilesCoursePath = path.join(course_path, 'serverFilesCourse');\n\n  // base workspace directory wherever we are uploading to\n  const remoteDirName = `workspace-${workspace_id}-${workspace.version}`;\n  const remotePath = path.join(remoteDirName, 'current');\n\n  const root = config.workspaceHomeDirRoot;\n  const destinationPath = path.join(root, remotePath);\n  const sourcePath = `${destinationPath}-${uuidv4()}`;\n\n  const { fileGenerationErrors } = await generateWorkspaceFiles({\n    serverFilesCoursePath,\n    questionBasePath,\n    params: variant.params,\n    correctAnswers: variant.true_answer,\n    targetPath: sourcePath,\n  });\n\n  // Update permissions so that the directory and all contents are owned by the workspace user\n  for await (const file of klaw(sourcePath)) {\n    await fsPromises.chown(\n      file.path,\n      config.workspaceJobsDirectoryOwnerUid,\n      config.workspaceJobsDirectoryOwnerGid,\n    );\n  }\n\n  if (fileGenerationErrors.length > 0) {\n    const output = fileGenerationErrors.map((error) => `${error.file}: ${error.msg}`).join('\\n');\n    await issues.insertIssue({\n      variantId: variant.id,\n      studentMessage: 'Error initializing workspace files',\n      instructorMessage: 'Error initializing workspace files',\n      manuallyReported: false,\n      courseCaused: true,\n      courseData: { workspace, variant, question, course },\n      systemData: {\n        courseErrData: {\n          // This is shown in the console log of the issue\n          outputBoth: output,\n          // This data is only shown if user is admin (e.g., in dev mode).\n          errors: fileGenerationErrors.map((error) => ({\n            ...error,\n            // Since error is typically not serializable, a custom object is created.\n            err: serializeError(error.err),\n          })),\n        },\n      },\n      userId: null,\n      authnUserId: null,\n    });\n  }\n\n  return { sourcePath, destinationPath };\n}\n\nexport async function generateWorkspaceFiles({\n  serverFilesCoursePath,\n  questionBasePath,\n  params,\n  correctAnswers,\n  targetPath,\n}: {\n  serverFilesCoursePath: string;\n  questionBasePath: string;\n  params: Record<string, any> | null;\n  correctAnswers: Record<string, any> | null;\n  targetPath: string;\n}): Promise<{ fileGenerationErrors: FileGenerationError[] }> {\n  const localPath = path.join(questionBasePath, 'workspace');\n  const templatePath = path.join(questionBasePath, 'workspaceTemplates');\n\n  const fileGenerationErrors: FileGenerationError[] = [];\n\n  const staticFiles: WorkspaceFile[] = (\n    await async\n      .mapSeries(klaw(localPath), async (file: klaw.Item): Promise<WorkspaceFile | null> => {\n        return file.stats.isFile()\n          ? { name: path.relative(localPath, file.path), localPath: file.path }\n          : null;\n      })\n      .catch(() => {\n        // Path does not exist or is not accessible, do nothing\n        return [] as (WorkspaceFile | null)[];\n      })\n  ).filter((file): file is WorkspaceFile => !!file);\n\n  const mustacheParams = { params, correct_answers: correctAnswers };\n\n  const templateFiles: WorkspaceFile[] = (\n    await async\n      .mapSeries(klaw(templatePath), async (file: klaw.Item): Promise<WorkspaceFile | null> => {\n        const generatedFileName = path.relative(\n          templatePath,\n          file.path.replace(/\\.mustache$/i, ''),\n        );\n        try {\n          if (!file.stats.isFile()) return null;\n          return {\n            name: generatedFileName,\n            buffer: mustache.render(\n              await fsPromises.readFile(file.path, { encoding: 'utf-8' }),\n              mustacheParams,\n            ),\n          };\n        } catch (err) {\n          fileGenerationErrors.push({\n            file: generatedFileName,\n            err,\n            msg: `Error rendering workspace template file: ${err.message}`,\n          });\n          // File cannot be rendered, treat file as static file\n          return { name: generatedFileName, localPath: file.path };\n        }\n      })\n      .catch(() => {\n        // Template directory does not exist or is not accessible, do nothing\n        return [] as (WorkspaceFile | null)[];\n      })\n  ).filter((file): file is WorkspaceFile => !!file);\n\n  const dynamicFiles: WorkspaceFile[] =\n    (params?._workspace_files as DynamicWorkspaceFile[] | null)\n      ?.map((file: DynamicWorkspaceFile, i: number): WorkspaceFile | null => {\n        // Ignore files without a name\n        if (!file?.name) {\n          fileGenerationErrors.push({\n            file: `Dynamic file ${i}`,\n            msg: 'Dynamic workspace file does not include a name. File ignored.',\n            data: file,\n          });\n          return null;\n        }\n        try {\n          // Discard names with directory traversal outside the home directory\n          if (!isContainedRelativePath(file.name, false)) {\n            fileGenerationErrors.push({\n              file: file.name,\n              msg: 'Dynamic workspace file has an absolute path or includes a name that traverses outside the home directory. File ignored.',\n              data: file,\n            });\n            return null;\n          }\n          const normalizedFilename = path.normalize(file.name);\n\n          if (file.questionFile || file.serverFilesCourseFile) {\n            const basePath = file.questionFile ? questionBasePath : serverFilesCoursePath;\n            const localPath = path.join(\n              basePath,\n              file.questionFile ?? file.serverFilesCourseFile ?? '',\n            );\n            // Discard paths with directory traversal outside the question\n            if (!contains(basePath, localPath, false)) {\n              fileGenerationErrors.push({\n                file: file.name,\n                msg: `Dynamic workspace file points to a local file outside the ${file.questionFile ? 'question' : 'serverFilesCourse'} directory. File ignored.`,\n                data: file,\n              });\n              return null;\n            }\n            // To avoid race conditions, no check if file exists here, rather an exception is\n            // captured when attempting to copy.\n            return {\n              name: normalizedFilename,\n              localPath,\n            };\n          }\n\n          // Discard encodings outside of explicit list of allowed encodings\n          if (file.encoding && !['utf-8', 'base64', 'hex'].includes(file.encoding)) {\n            fileGenerationErrors.push({\n              file: file.name,\n              msg: `Dynamic workspace file has unsupported file encoding (${file.encoding}). File ignored.`,\n              data: file,\n            });\n            return null;\n          }\n\n          if (!('contents' in file)) {\n            fileGenerationErrors.push({\n              file: file.name,\n              msg: 'Dynamic workspace file has neither \"contents\" nor \"questionFile\" nor \"serverFilesCourseFile\". Blank file created.',\n              data: file,\n            });\n          }\n\n          return {\n            name: normalizedFilename,\n            buffer: Buffer.from(file.contents ?? '', file.encoding || 'utf-8'),\n          };\n        } catch (err) {\n          // Error retrieving contents of dynamic file. Ignoring file.\n          fileGenerationErrors.push({\n            file: file.name,\n            msg: `Error decoding dynamic workspace file: ${err.message}`,\n            err,\n            data: file,\n          });\n          return null;\n        }\n      })\n      .filter((file): file is WorkspaceFile => !!file) ?? [];\n\n  const allWorkspaceFiles = staticFiles.concat(templateFiles).concat(dynamicFiles);\n\n  await fs.ensureDir(targetPath);\n\n  if (allWorkspaceFiles.length > 0) {\n    await async.eachSeries(allWorkspaceFiles, async (workspaceFile) => {\n      const targetFile = path.join(targetPath, workspaceFile.name);\n      try {\n        await fs.ensureDir(path.dirname(targetFile));\n        if ('localPath' in workspaceFile) {\n          await fs.copy(workspaceFile.localPath, targetFile);\n        } else {\n          await fs.writeFile(targetFile, workspaceFile.buffer);\n        }\n      } catch (err) {\n        fileGenerationErrors.push({\n          file: workspaceFile.name,\n          msg: `Workspace file could not be written to workspace: ${err.message}`,\n          err,\n          data: { workspaceFile },\n        });\n        debug(`File ${workspaceFile.name} could not be written`, err);\n      }\n    });\n  }\n\n  return { fileGenerationErrors };\n}\n\n/**\n * @returns The ID of the host that was assigned to the workspace.\n */\nasync function assignHost(workspace_id: string): Promise<string | null> {\n  if (!config.workspaceEnable) return null;\n\n  const workspaceHostId = await workspaceHostUtils.assignWorkspaceToHost(\n    workspace_id,\n    config.workspaceLoadHostCapacity,\n  );\n  debug(`assignHost(): workspace_id=${workspace_id}, workspace_host_id=${workspaceHostId}`);\n  return workspaceHostId; // null means we didn't assign a host\n}\n\nexport async function getGradedFiles(workspace_id: string): Promise<string | null> {\n  let zipPath: string | null = null;\n  const workspace = await sqldb.queryRow(sql.select_workspace, { workspace_id }, WorkspaceSchema);\n\n  if (workspace.state === 'uninitialized') {\n    // there are no files yet\n    return null;\n  }\n\n  if (workspace.state === 'running') {\n    // Attempt to get the files directly from the host.\n    try {\n      zipPath = await controlContainer(workspace_id, 'getGradedFiles');\n    } catch (err) {\n      logger.error('Error getting graded files from container', err);\n      if (err instanceof SubmissionFormatError) throw err;\n    }\n  }\n\n  // If this is null, something went wrong, so fall back to fetching from the filesystem.\n  if (zipPath == null) {\n    zipPath = await getGradedFilesFromFileSystem(workspace_id);\n  }\n\n  return zipPath;\n}\n\nasync function getGradedFilesFromFileSystem(workspace_id: string): Promise<string | null> {\n  const { workspace_version, workspace_graded_files } = await sqldb.queryRow(\n    sql.select_workspace_version_and_graded_files,\n    { workspace_id },\n    WorkspaceVersionAndGradedFilesSchema,\n  );\n  const zipPath = await tmp.tmpName({ postfix: '.zip' });\n\n  const archive = archiver('zip');\n  const remoteName = `workspace-${workspace_id}-${workspace_version}`;\n  const remoteDir = path.join(config.workspaceHomeDirRoot, remoteName, 'current');\n\n  let gradedFiles: Entry[];\n  try {\n    gradedFiles = await workspaceUtils.getWorkspaceGradedFiles(\n      remoteDir,\n      workspace_graded_files ?? [],\n      {\n        maxFiles: config.workspaceMaxGradedFilesCount,\n        maxSize: config.workspaceMaxGradedFilesSize,\n      },\n    );\n  } catch (err) {\n    // Turn any error into a `SubmissionFormatError` so that it is handled correctly.\n    throw new SubmissionFormatError(err.message);\n  }\n\n  // Zip files from filesystem to zip file\n  (gradedFiles ?? []).forEach((file) => {\n    const remotePath = path.join(remoteDir, file.path);\n    debug(`Zipping graded file ${remotePath} into ${zipPath}`);\n    archive.file(remotePath, { name: file.path });\n  });\n\n  // Write zip file to disk\n  const stream = fs.createWriteStream(zipPath);\n  await new Promise((resolve, reject) => {\n    archive.on('error', (err) => reject(err));\n\n    stream\n      .on('error', (err) => reject(err))\n      .on('finish', () => {\n        debug(`Zipped graded files as ${zipPath} (${archive.pointer()} total bytes)`);\n        resolve(zipPath);\n      });\n\n    archive.pipe(stream);\n    archive.finalize().catch((err) => reject(err));\n  });\n  return zipPath;\n}\n\nfunction serializeError(\n  err: (Error & { data?: any; cause?: Error }) | null,\n): (Error & { data?: any; cause?: Error }) | null {\n  if (err == null) return err;\n  return {\n    ...err,\n    stack: err.stack,\n    data: err.data,\n    message: err.message,\n    cause: err.cause,\n  };\n}\n"]}