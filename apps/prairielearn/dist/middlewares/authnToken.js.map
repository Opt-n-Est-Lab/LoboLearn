{"version":3,"file":"authnToken.js","sourceRoot":"","sources":["../../src/middlewares/authnToken.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AAEtC,OAAO,YAAY,MAAM,uBAAuB,CAAC;AAEjD,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAC9C,OAAO,KAAK,KAAK,MAAM,wBAAwB,CAAC;AAChD,OAAO,KAAK,MAAM,MAAM,sBAAsB,CAAC;AAE/C,MAAM,GAAG,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAEhD,eAAe,YAAY,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;IACnD,MAAM,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;IAE1C,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACxB,kCAAkC;QAClC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACnB,OAAO,EAAE,0CAA0C;SACpD,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACnB,OAAO,EAAE,+CAA+C;SACzD,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IAED,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,sBAAsB,CAAC,GAAG,CAAC,2BAA2B,EAAE;QACjF,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;KAC5E,CAAC,CAAC;IACH,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC7B,yBAAyB;QACzB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACnB,OAAO,EAAE,+CAA+C;SACzD,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IAED,GAAG,CAAC,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5C,GAAG,CAAC,MAAM,CAAC,gBAAgB,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC;IAE9D,+DAA+D;IAC/D,mCAAmC;IACnC,IAAI,EAAE,CAAC;IAEP,KAAK;SACF,UAAU,CAAC,GAAG,CAAC,sBAAsB,EAAE;QACtC,QAAQ,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ;KAClC,CAAC;SACD,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;QACb,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;QAC7B,MAAM,CAAC,KAAK,CAAC,qCAAqC,EAAE,GAAG,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;AACP,CAAC,CAAC,CAAC","sourcesContent":["import * as crypto from 'node:crypto';\n\nimport asyncHandler from 'express-async-handler';\n\nimport { logger } from '@prairielearn/logger';\nimport * as sqldb from '@prairielearn/postgres';\nimport * as Sentry from '@prairielearn/sentry';\n\nconst sql = sqldb.loadSqlEquiv(import.meta.url);\n\nexport default asyncHandler(async (req, res, next) => {\n  const token = req.header('Private-Token');\n\n  if (token === undefined) {\n    // No authentication token present\n    res.status(401).send({\n      message: 'An authentication token must be provided',\n    });\n    return;\n  }\n\n  if (typeof token !== 'string') {\n    res.status(401).send({\n      message: 'The provided authentication token was invalid',\n    });\n    return;\n  }\n\n  const result = await sqldb.queryZeroOrOneRowAsync(sql.select_user_from_token_hash, {\n    token_hash: crypto.createHash('sha256').update(token, 'utf8').digest('hex'),\n  });\n  if (result.rows.length === 0) {\n    // Invalid token received\n    res.status(401).send({\n      message: 'The provided authentication token was invalid',\n    });\n    return;\n  }\n\n  res.locals.authn_user = result.rows[0].user;\n  res.locals.is_administrator = result.rows[0].is_administrator;\n\n  // Let's note that this token was used, but don't wait for this\n  // to continue handling the request\n  next();\n\n  sqldb\n    .queryAsync(sql.update_token_last_used, {\n      token_id: result.rows[0].token_id,\n    })\n    .catch((err) => {\n      Sentry.captureException(err);\n      logger.error('Error in sql.update_token_last_used', err);\n    });\n});\n"]}