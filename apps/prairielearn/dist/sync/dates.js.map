{"version":3,"file":"dates.js","sourceRoot":"","sources":["../../src/sync/dates.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,UAAU,CAAC;AAEvD,MAAM,UAAU,8BAA8B,CAAC,EAAE,OAAO,EAA+B;IACrF,IAAI,CAAC,OAAO;QAAE,OAAO,IAAI,CAAC;IAE1B,wEAAwE;IACxE,wEAAwE;IACxE,uEAAuE;IACvE,4DAA4D;IAC5D,EAAE;IACF,wEAAwE;IACxE,6DAA6D;IAC7D,EAAE;IACF,gFAAgF;IAChF,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;IACrC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;QAAE,OAAO,KAAK,CAAC;IACvC,OAAO,QAAQ,CAAC,UAAU,CAAC,CAAC;AAC9B,CAAC","sourcesContent":["import { isFuture, isValid, parseISO } from 'date-fns';\n\nexport function isAccessRuleAccessibleInFuture({ endDate }: { endDate?: string | null }) {\n  if (!endDate) return true;\n\n  // We don't have easy access to the course instance's timezone, so we'll\n  // just parse it in the machine's local timezone. This is fine, as we're\n  // only interesting in a rough signal of whether the end date is in the\n  // future. If we're off by up to a day, it's not a big deal.\n  //\n  // If the date is invalid, we'll treat it as though it's in the past and\n  // thus that it does not make the course instance accessible.\n  //\n  // `parseISO` is used instead of `new Date` for consistency with `course-db.ts`.\n  const parsedDate = parseISO(endDate);\n  if (!isValid(parsedDate)) return false;\n  return isFuture(parsedDate);\n}\n"]}