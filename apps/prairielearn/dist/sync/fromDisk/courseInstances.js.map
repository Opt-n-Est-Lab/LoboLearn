{"version":3,"file":"courseInstances.js","sourceRoot":"","sources":["../../../src/sync/fromDisk/courseInstances.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\n\nimport * as sqldb from '@prairielearn/postgres';\n\nimport { config } from '../../lib/config.js';\nimport { IdSchema } from '../../lib/db-types.js';\nimport { type CourseInstanceJson } from '../../schemas/index.js';\nimport { type CourseData } from '../course-db.js';\nimport { isAccessRuleAccessibleInFuture } from '../dates.js';\nimport * as infofile from '../infofile.js';\n\nconst sql = sqldb.loadSqlEquiv(import.meta.filename);\n\nfunction getParamsForCourseInstance(courseInstance: CourseInstanceJson | null | undefined) {\n  if (!courseInstance) return null;\n\n  // It used to be the case that instance access rules could be associated with a\n  // particular user role, e.g., Student, TA, or Instructor. Now, all access rules\n  // apply only to students. So, we filter out (and ignore) any access rule with a\n  // non-empty role that is not Student.\n  const accessRules = (courseInstance.allowAccess || [])\n    .filter((accessRule) => !('role' in accessRule) || accessRule.role === 'Student')\n    .map((accessRule) => ({\n      uids: accessRule.uids ?? null,\n      start_date: accessRule.startDate ?? null,\n      end_date: accessRule.endDate ?? null,\n      institution: accessRule.institution ?? null,\n    }));\n\n  return {\n    uuid: courseInstance.uuid,\n    long_name: courseInstance.longName,\n    hide_in_enroll_page: courseInstance.hideInEnrollPage || false,\n    display_timezone: courseInstance.timezone || null,\n    access_rules: accessRules,\n    assessments_group_by: courseInstance.groupAssessmentsBy,\n  };\n}\n\nexport async function sync(\n  courseId: string,\n  courseData: CourseData,\n): Promise<Record<string, string>> {\n  if (config.checkInstitutionsOnSync) {\n    // Collect all institutions from course instance access rules.\n    const institutions = Object.values(courseData.courseInstances)\n      .flatMap(({ courseInstance }) => courseInstance.data?.allowAccess)\n      .map((accessRule) => accessRule?.institution)\n      .filter((institution) => institution != null);\n\n    // Select only the valid institution names.\n    const validInstitutions = await sqldb.queryRows(\n      sql.select_valid_institution_short_names,\n      { short_names: Array.from(new Set(institutions)) },\n      z.string(),\n    );\n\n    const validInstitutionSet = new Set(validInstitutions);\n\n    // This is a special hardcoded value that is always valid.\n    validInstitutionSet.add('Any');\n\n    // Add sync errors for invalid institutions.\n    Object.values(courseData.courseInstances).forEach(({ courseInstance }) => {\n      // Note that we only emit errors for institutions referenced from access\n      // rules that will be accessible at some point in the future. This lets\n      // us avoid emitting errors for very old, unused course instances.\n      const instanceInstitutions = new Set(\n        courseInstance.data?.allowAccess\n          ?.filter(isAccessRuleAccessibleInFuture)\n          ?.map((accessRule) => accessRule?.institution)\n          .filter((institution) => institution != null),\n      );\n\n      instanceInstitutions.forEach((institution) => {\n        if (validInstitutionSet.has(institution)) return;\n\n        infofile.addError(courseInstance, `Institution \"${institution}\" not found.`);\n      });\n    });\n  }\n\n  const courseInstanceParams = Object.entries(courseData.courseInstances).map(\n    ([shortName, courseInstanceData]) => {\n      const { courseInstance } = courseInstanceData;\n      return JSON.stringify([\n        shortName,\n        courseInstance.uuid,\n        infofile.stringifyErrors(courseInstance),\n        infofile.stringifyWarnings(courseInstance),\n        getParamsForCourseInstance(courseInstance.data),\n      ]);\n    },\n  );\n\n  const result = await sqldb.callRow(\n    'sync_course_instances',\n    [courseInstanceParams, courseId],\n    z.record(z.string(), IdSchema),\n  );\n\n  return result;\n}\n"]}