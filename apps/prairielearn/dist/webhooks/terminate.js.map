{"version":3,"file":"terminate.js","sourceRoot":"","sources":["../../src/webhooks/terminate.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,QAAQ,CAAC;AAEjC,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACjC,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAE9C,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAE1C,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC;AAExB;;;;;;;;;;GAUG;AACH,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE;IAClC,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,wBAAwB,CAAC,CAAC;QAClD,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,uCAAuC,CAAC,CAAC;YAC9D,OAAO;QACT,CAAC;QACD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,yCAAyC,CAAC,CAAC;YAChE,OAAO;QACT,CAAC;QAED,IAAI,CAAC;YACH,MAAM,GAAG,GAAG,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YAC9D,MAAM,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE;gBAC7B,MAAM,EAAE,cAAc;gBACtB,OAAO,EAAE,WAAW;aACrB,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,MAAM,CAAC,KAAK,CAAC,8CAA8C,EAAE,GAAG,CAAC,CAAC;YAClE,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,0CAA0C,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YAC9E,OAAO;QACT,CAAC;QAED,0EAA0E;QAC1E,2EAA2E;QAC3E,yEAAyE;QACzE,4EAA4E;QAC5E,gBAAgB;QAChB,EAAE;QACF,mEAAmE;QACnE,gEAAgE;QAChE,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;QAC1B,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;YACnB,MAAM,EAAE,GAAG,CAAC,GAAG,EAAE;gBACf,MAAM,CAAC,OAAO,EAAE,CAAC;gBACjB,MAAM,CAAC,IAAI,CAAC,2CAA2C,CAAC,CAAC;gBACzD,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IACtC,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,MAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE,GAAG,CAAC,CAAC;QAChD,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACpC,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,eAAe,MAAM,CAAC","sourcesContent":["import * as crypto from 'crypto';\n\nimport { Router } from 'express';\nimport * as jose from 'jose';\n\nimport { logger } from '@prairielearn/logger';\n\nimport { config } from '../lib/config.js';\n\nconst router = Router();\n\n/**\n * This is a webhook that can be called when infrastructure wants this instance\n * of the app to terminate. This is useful e.g. as part of deploy tooling. It\n * will send SIGTERM to the current process, which will cause it to exit\n * gracefully.\n *\n * This app requires a signed `PrairieLearn-Signature` JWT header to be present,\n * so it's safe to publicly expose this endpoint if needed. However, it's\n * recommended that this endpoint be blocked at your load balancer or firewall\n * for extra security.\n */\nrouter.post('/', async (req, res) => {\n  try {\n    const jwt = req.headers['prairielearn-signature'];\n    if (!jwt) {\n      res.status(403).send('Missing PrairieLearn-Signature header');\n      return;\n    }\n    if (Array.isArray(jwt)) {\n      res.status(403).send('Multiple PrairieLearn-Signature headers');\n      return;\n    }\n\n    try {\n      const key = crypto.createSecretKey(config.secretKey, 'utf-8');\n      await jose.jwtVerify(jwt, key, {\n        issuer: 'PrairieLearn',\n        subject: 'terminate',\n      });\n    } catch (err) {\n      logger.error('Error decoding PrairieLearn-Signature header', err);\n      res.status(403).send(`Invalid PrairieLearn-Signature header: ${err.message}`);\n      return;\n    }\n\n    // If a client uses a keepalive connection, we'd be temporarily deadlocked\n    // if we waited for the client to close the connection, as `server.close()`\n    // in `server.js` won't finish until all connections have closed. To work\n    // around this, we'll explicitly close the underlying socket once we've sent\n    // the response.\n    //\n    // TODO: Once we have a minimum Node version of 18.2, we should use\n    // `server.closeIdleConnections` in `server.js` instead of this.\n    const socket = res.socket;\n    res.on('close', () => {\n      socket?.end(() => {\n        socket.destroy();\n        logger.info('Terminating server due to webhook request');\n        process.kill(process.pid, 'SIGTERM');\n      });\n    });\n\n    res.status(200).send('Terminating');\n  } catch (err) {\n    logger.error('Error in terminate webhook', err);\n    res.status(500).send(err.message);\n  }\n});\n\nexport default router;\n"]}