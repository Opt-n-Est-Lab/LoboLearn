{
  "version": 3,
  "sources": ["../../../../../node_modules/morphdom/dist/morphdom-esm.js", "../../../../../packages/browser-utils/src/on-document-ready.ts", "../../../../../node_modules/js-base64/base64.mjs", "../../../../../packages/html/src/index.ts", "../../../../../packages/browser-utils/src/encode-data.ts", "../../../src/ee/lib/billing/plans-types.ts", "../../../src/ee/lib/billing/components/InstructorInstanceAdminBillingForm.html.ts", "../../../assets/scripts/instructorInstanceAdminBillingClient.ts"],
  "sourcesContent": ["var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n", "export function onDocumentReady(fn: () => void): void {\n  if (document.readyState === 'interactive' || document.readyState === 'complete') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', () => {\n      fn();\n    });\n  }\n}\n", "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 \u00A75\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 \u00A75.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n", "const ENCODE_HTML_RULES: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;',\n};\nconst MATCH_HTML = /[&<>'\"]/g;\n\nfunction encodeCharacter(c: string) {\n  return ENCODE_HTML_RULES[c] || c;\n}\n\n/**\n * Based on the `escapeXML` function from the `ejs` library.\n */\nfunction escapeHtmlRaw(value: string): string {\n  return value == null ? '' : String(value).replace(MATCH_HTML, encodeCharacter);\n}\n\nfunction escapeValue(value: unknown): string {\n  if (value instanceof HtmlSafeString) {\n    // Already escaped!\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return value.map((val) => escapeValue(val)).join('');\n  } else if (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'bigint' ||\n    typeof value === 'boolean'\n  ) {\n    return escapeHtmlRaw(String(value));\n  } else if (value == null) {\n    // undefined or null -- render nothing\n    return '';\n  } else if (typeof value === 'object') {\n    throw new Error(`Cannot interpolate object in template: ${JSON.stringify(value)}`);\n  } else {\n    // There shouldn't be any other types\n    throw new Error(\n      `Unexpected type in template: ${typeof value} for value ${JSON.stringify(value)}`,\n    );\n  }\n}\n\n// Based on https://github.com/Janpot/escape-html-template-tag\nexport class HtmlSafeString {\n  private readonly strings: readonly string[];\n  private readonly values: unknown[];\n\n  constructor(strings: readonly string[], values: unknown[]) {\n    this.strings = strings;\n    this.values = values;\n  }\n\n  toString(): string {\n    return this.values.reduce<string>((acc, val, i) => {\n      return acc + escapeValue(val) + this.strings[i + 1];\n    }, this.strings[0]);\n  }\n}\n\nexport type HtmlValue =\n  | string\n  | number\n  | boolean\n  | bigint\n  | HtmlSafeString\n  | undefined\n  | null\n  | HtmlValue[];\n\nexport function html(strings: TemplateStringsArray, ...values: HtmlValue[]): HtmlSafeString {\n  return new HtmlSafeString(strings, values);\n}\n\n/**\n * Pre-escapes the rendered HTML. Useful for when you want to inline the HTML\n * in something else, for instance in a `data-bs-content` attribute for a Bootstrap\n * popover.\n */\nexport function escapeHtml(html: HtmlSafeString): HtmlSafeString {\n  return unsafeHtml(escapeHtmlRaw(html.toString()));\n}\n\n/**\n * Will render the provided value without any additional escaping. Use carefully\n * with user-provided data.\n *\n * @param value The value to render.\n * @returns An {@link HtmlSafeString} representing the provided value.\n */\nexport function unsafeHtml(value: string): HtmlSafeString {\n  return new HtmlSafeString([value], []);\n}\n\n/**\n * Joins a list of HTML values with a separator.\n *\n * @param values The values to join.\n * @param separator The separator to use between values.\n */\nexport function joinHtml(values: HtmlValue[], separator: HtmlValue = ''): HtmlSafeString {\n  return unsafeHtml(values.map(escapeValue).join(escapeValue(separator)));\n}\n", "import { decode, encode } from 'js-base64';\n\nimport { type HtmlSafeString, html, unsafeHtml } from '@prairielearn/html';\n\n/**\n * Use this function as an HTML component encode data that will be passed to the client.\n *\n * @param data The data to encode.\n * @param elementId The element ID to use for the encoded data.\n *\n */\nexport function EncodedData<T = unknown>(data: T, elementId: string): HtmlSafeString {\n  const encodedData = unsafeHtml(encode(JSON.stringify(data)));\n  return html`<script id=\"${elementId}\" type=\"application/base64\">\n    ${encodedData}\n  </script>`;\n}\n\n/**\n * Decode data that was passed to the client from in HTML component using EncodeData().\n *\n * @param elementId The element ID that stores the encoded data, from from EncodedData().\n * @returns The decoded data.\n */\nexport function decodeData<T = any>(elementId: string): T {\n  const base64Data = document.getElementById(elementId)?.textContent;\n  if (base64Data == null) {\n    throw new Error(`No data found in element with ID \"${elementId}\"`);\n  }\n  const jsonData = decode(base64Data);\n  const data = JSON.parse(jsonData);\n  return data;\n}\n", "export const PLAN_FEATURE_NAMES = [\n  'course-instance-access',\n  'external-grading',\n  'workspaces',\n] as const;\nexport const PLAN_NAMES = ['basic', 'compute', 'everything'] as const;\n\nexport type PlanFeatureName = (typeof PLAN_FEATURE_NAMES)[number];\nexport type PlanName = (typeof PLAN_NAMES)[number];\n\ninterface Plan {\n  features: PlanFeatureName[];\n  initialEnrollmentLimit?: number;\n}\n\nexport const PLANS = {\n  // Enabled when student billing for enrollments is enabled for a course instance.\n  basic: {\n    features: ['course-instance-access'],\n  },\n  // Enables workspaces and external grading. Can be used in combination with\n  // the `basic` plan (for a course using student billing for enrollments) or\n  // in isolation (a course instance's institution is paying for the basic plan\n  // but the course instance wants to use workspaces and external grading).\n  compute: {\n    features: ['workspaces', 'external-grading'],\n  },\n  // All features that exist.\n  everything: {\n    features: ['workspaces', 'external-grading'],\n  },\n} satisfies Record<PlanName, Plan>;\n\nexport function getFeaturesForPlans(plans: PlanName[]): PlanFeatureName[] {\n  const features = new Set<PlanFeatureName>();\n  for (const plan of plans) {\n    PLANS[plan].features.forEach((feature) => features.add(feature));\n  }\n  return Array.from(features);\n}\n\nexport function planGrantsMatchPlanFeatures(grantedPlans: PlanName[], plans: PlanName[]): boolean {\n  const planGrantsFeatures = getFeaturesForPlans(grantedPlans);\n  const planFeatures = getFeaturesForPlans(plans);\n  return (\n    planGrantsFeatures.length === planFeatures.length &&\n    planGrantsFeatures.every((feature) => planFeatures.includes(feature))\n  );\n}\n", "import { EncodedData } from '@prairielearn/browser-utils';\nimport { html } from '@prairielearn/html';\n\nimport { type PlanName, planGrantsMatchPlanFeatures } from '../plans-types.js';\n\ninterface InstructorInstanceAdminBillingInput {\n  initialRequiredPlans: PlanName[];\n  desiredRequiredPlans: PlanName[];\n  institutionPlanGrants: PlanName[];\n  courseInstancePlanGrants: PlanName[];\n  enrollmentCount: number;\n  enrollmentLimit: number;\n  editable: boolean;\n}\n\ninterface InstructorInstanceAdminBillingState {\n  studentBillingEnabled: boolean;\n  studentBillingCanChange: boolean;\n  studentBillingDidChange: boolean;\n  studentBillingAlert: AlertProps | null;\n  computeEnabled: boolean;\n  computeCanChange: boolean;\n  computeDidChange: boolean;\n  computeAlert: AlertProps | null;\n}\n\ninterface AlertProps {\n  message: string;\n  color: 'success' | 'warning' | 'danger';\n}\n\nexport function instructorInstanceAdminBillingState(\n  input: InstructorInstanceAdminBillingInput,\n): InstructorInstanceAdminBillingState {\n  const studentBillingInitialEnabled = input.initialRequiredPlans.includes('basic');\n  const studentBillingEnabled = input.desiredRequiredPlans.includes('basic');\n  const computeEnabledByInstitution = planGrantsMatchPlanFeatures(input.institutionPlanGrants, [\n    'compute',\n  ]);\n  const computeEnabledByCourseInstance = planGrantsMatchPlanFeatures(\n    input.courseInstancePlanGrants,\n    ['compute'],\n  );\n  const computeEnabled =\n    (!studentBillingEnabled && (computeEnabledByInstitution || computeEnabledByCourseInstance)) ||\n    input.desiredRequiredPlans.includes('compute');\n\n  let studentBillingCanChange = input.editable;\n  const studentBillingDidChange =\n    input.initialRequiredPlans.includes('basic') !== input.desiredRequiredPlans.includes('basic');\n  let studentBillingAlert: AlertProps | null = null;\n  if (studentBillingInitialEnabled && input.enrollmentCount > input.enrollmentLimit) {\n    studentBillingCanChange = false;\n    const inflectedCountVerb = input.enrollmentCount === 1 ? 'is' : 'are';\n    const inflectedCountNoun = input.enrollmentCount === 1 ? 'enrollment' : 'enrollments';\n    studentBillingAlert = {\n      message: [\n        `There ${inflectedCountVerb} ${input.enrollmentCount} ${inflectedCountNoun} in this course, which exceeds the limit of ${input.enrollmentLimit}.`,\n        'To disable student billing, first remove excess enrollments.',\n      ].join(' '),\n      color: 'warning',\n    };\n  }\n\n  let computeCanChange = input.editable;\n  const computeDidChange =\n    input.initialRequiredPlans.includes('compute') !==\n    input.desiredRequiredPlans.includes('compute');\n  let computeAlert: AlertProps | null = null;\n  if (!studentBillingEnabled && (computeEnabledByInstitution || computeEnabledByCourseInstance)) {\n    computeCanChange = false;\n    computeAlert = {\n      message:\n        'This course instance already has access to compute features without additional payment.',\n      color: 'success',\n    };\n  }\n\n  return {\n    studentBillingEnabled,\n    studentBillingCanChange,\n    studentBillingDidChange,\n    studentBillingAlert,\n    computeEnabled,\n    computeCanChange,\n    computeDidChange,\n    computeAlert,\n  };\n}\n\nexport interface InstructorInstanceAdminBillingFormProps\n  extends InstructorInstanceAdminBillingInput {\n  enrollmentLimitSource: 'course_instance' | 'institution';\n  externalGradingQuestionCount: number;\n  workspaceQuestionCount: number;\n  csrfToken: string;\n}\n\nexport function InstructorInstanceAdminBillingForm(props: InstructorInstanceAdminBillingFormProps) {\n  const {\n    enrollmentCount,\n    enrollmentLimit,\n    enrollmentLimitSource,\n    externalGradingQuestionCount,\n    workspaceQuestionCount,\n    editable,\n    csrfToken,\n  } = props;\n\n  const {\n    studentBillingEnabled,\n    studentBillingCanChange,\n    studentBillingAlert,\n    computeEnabled,\n    computeCanChange,\n    computeAlert,\n  } = instructorInstanceAdminBillingState(props);\n\n  const enrollmentLimitPercentage = Math.min(100, (enrollmentCount / enrollmentLimit) * 100);\n  const enrollmentLimitExceeded = enrollmentCount > enrollmentLimit;\n\n  // Make the colored portion of the progress bar at least 2% wide at all\n  // times to ensure that it's not just a gray box.\n  const enrollmentLimitProgressBarPercentage = Math.max(2, enrollmentLimitPercentage);\n  const enrollmentLimitProgressBarColor = enrollmentLimitExceeded\n    ? 'bg-danger'\n    : enrollmentLimitPercentage > 90\n      ? 'bg-warning'\n      : 'bg-primary';\n\n  return html`\n    <form method=\"POST\" class=\"js-billing-form\">\n      ${EncodedData(props, 'billing-form-data')}\n      <h2 class=\"h4\">Enrollments</h2>\n      <div class=\"mb-3\">\n        <div class=\"d-flex flex-row align-items-center\">\n          <span class=\"me-2\">\n            ${formatEnrollmentCount(enrollmentCount, enrollmentLimit, studentBillingEnabled)}\n          </span>\n          <div\n            class=\"progress flex-grow-1 ${studentBillingEnabled ? 'd-none' : ''}\"\n            style=\"max-width: 100px\"\n          >\n            <div\n              class=\"progress-bar ${enrollmentLimitProgressBarColor}\"\n              role=\"progressbar\"\n              style=\"width: ${enrollmentLimitProgressBarPercentage}%\"\n              aria-valuenow=\"${enrollmentCount}\"\n              aria-valuemin=\"0\"\n              aria-valuemax=\"${enrollmentLimit}\"\n            ></div>\n          </div>\n        </div>\n        <div class=\"small text-muted\">\n          ${enrollmentLimitExplanation({\n            studentBillingEnabled,\n            enrollmentLimit,\n            enrollmentLimitSource,\n          })}\n        </div>\n      </div>\n\n      <div class=\"form-check\">\n        <input\n          class=\"form-check-input\"\n          type=\"checkbox\"\n          name=\"student_billing_enabled\"\n          ${studentBillingEnabled ? 'checked' : ''}\n          value=\"1\"\n          id=\"studentBillingEnabled\"\n          ${!studentBillingCanChange ? 'disabled' : ''}\n        />\n        <label class=\"form-check-label\" for=\"studentBillingEnabled\">\n          Enable student billing for enrollments\n        </label>\n        <p class=\"small text-muted\">\n          When student billing is enabled, students pay for access to your course instance. Enabling\n          student billing will allow your course instance to exceed any enrollment limits that would\n          otherwise apply.\n        </p>\n        ${MaybeAlert(studentBillingAlert)}\n      </div>\n\n      <h2 class=\"h4\">Features</h2>\n      <p>\n        If your course requires certain features, you can enable them so that students can pay for\n        them.\n      </p>\n\n      <div class=\"form-check\">\n        <input\n          class=\"form-check-input\"\n          type=\"checkbox\"\n          name=\"compute_enabled\"\n          ${computeEnabled ? 'checked' : ''}\n          value=\"1\"\n          id=\"computeEnabled\"\n          ${!computeCanChange ? 'disabled' : ''}\n        />\n        <label class=\"form-check-label\" for=\"computeEnabled\">\n          External grading and workspaces\n        </label>\n        <p class=\"small text-muted\">\n          Students will be able to use questions that utilize external grading and/or workspaces.\n          This course has\n          <strong>${pluralizeQuestionCount(externalGradingQuestionCount)}</strong> that use external\n          grading and <strong>${pluralizeQuestionCount(workspaceQuestionCount)}</strong> that use\n          workspaces.\n        </p>\n        ${MaybeAlert(computeAlert)}\n      </div>\n\n      <div\n        class=\"alert alert-warning js-student-billing-warning\"\n        data-student-billing-enabled=\"${studentBillingEnabled}\"\n        data-compute-enabled=\"${computeEnabled}\"\n        data-enrollment-count=\"${enrollmentCount}\"\n        data-enrollment-limit=\"${enrollmentLimit}\"\n        hidden\n      >\n        Any students currently enrolled in your course will lose access until they have paid for the\n        above features. If your course is currently in session, you should carefully consider the\n        impact of enabling student billing. Before proceeding, you should communicate this change to\n        your students.\n      </div>\n\n      <input type=\"hidden\" name=\"__csrf_token\" value=\"${csrfToken}\" />\n      <button type=\"submit\" class=\"btn btn-primary\" ${!editable ? 'disabled' : null}>Save</button>\n    </form>\n  `;\n}\n\nfunction MaybeAlert(props: AlertProps | null) {\n  if (!props) return null;\n  return html`<div class=\"alert alert-${props.color}\">${props.message}</div>`;\n}\n\nfunction enrollmentLimitExplanation({\n  studentBillingEnabled,\n  enrollmentLimit,\n  enrollmentLimitSource,\n}: {\n  studentBillingEnabled: boolean;\n  enrollmentLimit: number;\n  enrollmentLimitSource: 'course_instance' | 'institution';\n}): string {\n  if (studentBillingEnabled) {\n    return 'Student billing for enrollments is enabled, so there is no enrollment limit.';\n  }\n\n  if (enrollmentLimitSource === 'course_instance') {\n    return `This course instance has an enrollment limit of ${enrollmentLimit}.`;\n  }\n\n  return `This course's institution has a per-course-instance enrollment limit of ${enrollmentLimit}.`;\n}\n\nfunction pluralizeQuestionCount(count: number) {\n  return count === 1 ? `${count} question` : `${count} questions`;\n}\n\nfunction formatEnrollmentCount(\n  enrollmentCount: number,\n  enrollmentLimit: number,\n  studentBillingEnabled: boolean,\n) {\n  if (studentBillingEnabled) {\n    const pluralizedEnrollments = enrollmentCount === 1 ? 'enrollment' : 'enrollments';\n\n    // Student billing doesn't have a limit, so don't show it.\n    return `${enrollmentCount} ${pluralizedEnrollments}`;\n  } else {\n    const pluralizedEnrollments = enrollmentLimit === 1 ? 'enrollment' : 'enrollments';\n\n    return `${enrollmentCount} / ${enrollmentLimit} ${pluralizedEnrollments}`;\n  }\n}\n", "import morphdom from 'morphdom';\n\nimport { decodeData, onDocumentReady } from '@prairielearn/browser-utils';\n\nimport {\n  InstructorInstanceAdminBillingForm,\n  type InstructorInstanceAdminBillingFormProps,\n} from '../../src/ee/lib/billing/components/InstructorInstanceAdminBillingForm.html.js';\nimport { type PlanName } from '../../src/ee/lib/billing/plans-types.js';\n\nonDocumentReady(() => {\n  const billingForm = document.querySelector<HTMLFormElement>('.js-billing-form');\n  const initialProps = decodeData<InstructorInstanceAdminBillingFormProps>('billing-form-data');\n\n  const studentBillingCheckbox = document.querySelector<HTMLInputElement>('#studentBillingEnabled');\n  const computeCheckbox = document.querySelector<HTMLInputElement>('#computeEnabled');\n\n  if (!billingForm || !studentBillingCheckbox || !computeCheckbox) return;\n\n  billingForm.addEventListener('change', () => {\n    const basicPlanEnabled = studentBillingCheckbox.checked;\n    const computePlanEnabled = computeCheckbox.checked;\n\n    const requiredPlans: PlanName[] = [];\n    if (basicPlanEnabled) requiredPlans.push('basic');\n    if (computePlanEnabled) requiredPlans.push('compute');\n\n    morphdom(\n      billingForm,\n      InstructorInstanceAdminBillingForm({\n        ...initialProps,\n        desiredRequiredPlans: requiredPlans,\n      }).toString(),\n    );\n  });\n});\n"],
  "mappings": "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",
  "names": ["DOCUMENT_FRAGMENT_NODE", "morphAttrs", "fromNode", "toNode", "toNodeAttrs", "attr", "attrName", "attrNamespaceURI", "attrValue", "fromValue", "i", "fromNodeAttrs", "d", "range", "NS_XHTML", "doc", "HAS_TEMPLATE_SUPPORT", "HAS_RANGE_SUPPORT", "createFragmentFromTemplate", "str", "template", "createFragmentFromRange", "fragment", "createFragmentFromWrap", "toElement", "compareNodeNames", "fromEl", "toEl", "fromNodeName", "toNodeName", "fromCodeStart", "toCodeStart", "createElementNS", "name", "namespaceURI", "moveChildren", "curChild", "nextChild", "syncBooleanAttrProp", "specialElHandlers", "parentNode", "parentName", "newValue", "firstChild", "oldValue", "selectedIndex", "optgroup", "nodeName", "ELEMENT_NODE", "DOCUMENT_FRAGMENT_NODE$1", "TEXT_NODE", "COMMENT_NODE", "noop", "defaultGetNodeKey", "node", "morphdomFactory", "options", "toNodeHtml", "getNodeKey", "onBeforeNodeAdded", "onNodeAdded", "onBeforeElUpdated", "onElUpdated", "onBeforeNodeDiscarded", "onNodeDiscarded", "onBeforeElChildrenUpdated", "skipFromChildren", "addChild", "parent", "child", "childrenOnly", "fromNodesLookup", "keyedRemovalList", "addKeyedRemoval", "key", "walkDiscardedChildNodes", "skipKeyedNodes", "removeNode", "indexTree", "handleNodeAdded", "el", "nextSibling", "unmatchedFromEl", "morphEl", "cleanupFromEl", "curFromNodeChild", "curFromNodeKey", "fromNextSibling", "toElKey", "beforeUpdateResult", "morphChildren", "skipFrom", "curToNodeChild", "curToNodeKey", "toNextSibling", "matchingFromEl", "outer", "curFromNodeType", "isCompatible", "onBeforeNodeAddedResult", "specialElHandler", "morphedNode", "morphedNodeType", "toNodeType", "len", "elToRemove", "morphdom", "morphdom_esm_default", "onDocumentReady", "fn", "_hasBuffer", "_TD", "_TE", "b64ch", "b64chs", "b64tab", "a", "tab", "c", "i", "b64re", "_fromCC", "_U8Afrom", "it", "_mkUriSafe", "src", "m0", "_tidyB64", "s", "btoaPolyfill", "bin", "u32", "c0", "c1", "c2", "asc", "pad", "_btoa", "_fromUint8Array", "u8a", "strs", "l", "cb_utob", "c", "cc", "_fromCC", "re_utob", "utob", "u", "_encode", "_hasBuffer", "s", "_TE", "_fromUint8Array", "_btoa", "encode", "src", "urlsafe", "_mkUriSafe", "re_btou", "cb_btou", "cccc", "cp", "offset", "_fromCC", "btou", "b", "atobPolyfill", "asc", "b64re", "u24", "bin", "r1", "r2", "i", "b64tab", "_atob", "_tidyB64", "_hasBuffer", "_toUint8Array", "a", "_U8Afrom", "c", "_decode", "_hasBuffer", "a", "_TD", "_toUint8Array", "btou", "_atob", "_unURI", "_tidyB64", "m0", "decode", "src", "ENCODE_HTML_RULES", "MATCH_HTML", "encodeCharacter", "c", "escapeHtmlRaw", "value", "escapeValue", "HtmlSafeString", "val", "strings", "values", "__publicField", "acc", "i", "html", "unsafeHtml", "value", "HtmlSafeString", "_a", "EncodedData", "data", "elementId", "encodedData", "unsafeHtml", "encode", "html", "__template", "decodeData", "base64Data", "jsonData", "decode", "PLANS", "getFeaturesForPlans", "plans", "features", "plan", "feature", "planGrantsMatchPlanFeatures", "grantedPlans", "planGrantsFeatures", "planFeatures", "instructorInstanceAdminBillingState", "input", "studentBillingInitialEnabled", "studentBillingEnabled", "computeEnabledByInstitution", "planGrantsMatchPlanFeatures", "computeEnabledByCourseInstance", "computeEnabled", "studentBillingCanChange", "studentBillingDidChange", "studentBillingAlert", "inflectedCountVerb", "inflectedCountNoun", "computeCanChange", "computeDidChange", "computeAlert", "InstructorInstanceAdminBillingForm", "props", "enrollmentCount", "enrollmentLimit", "enrollmentLimitSource", "externalGradingQuestionCount", "workspaceQuestionCount", "editable", "csrfToken", "enrollmentLimitPercentage", "enrollmentLimitExceeded", "enrollmentLimitProgressBarPercentage", "enrollmentLimitProgressBarColor", "html", "EncodedData", "formatEnrollmentCount", "enrollmentLimitExplanation", "MaybeAlert", "pluralizeQuestionCount", "count", "onDocumentReady", "billingForm", "initialProps", "decodeData", "studentBillingCheckbox", "computeCheckbox", "basicPlanEnabled", "computePlanEnabled", "requiredPlans", "morphdom_esm_default", "InstructorInstanceAdminBillingForm", "__spreadProps", "__spreadValues"]
}
