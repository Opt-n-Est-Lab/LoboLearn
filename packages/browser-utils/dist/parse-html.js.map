{"version":3,"file":"parse-html.js","sourceRoot":"","sources":["../src/parse-html.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,SAAS,CAAC,QAAkB,EAAE,IAA6B;IACzE,IAAI,OAAO,IAAI,KAAK,QAAQ;QAAE,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IACrD,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;IACpD,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;IAC1B,OAAO,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACrD,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,gBAAgB,CAC9B,QAAkB,EAClB,IAA6B;IAE7B,MAAM,gBAAgB,GAAG,SAAS,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACnD,IAAI,gBAAgB,CAAC,iBAAiB,KAAK,CAAC,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;IAClE,CAAC;IACD,OAAO,gBAAgB,CAAC,iBAAsB,CAAC;AACjD,CAAC","sourcesContent":["import type { HtmlSafeString } from '@prairielearn/html';\n\nexport function parseHTML(document: Document, html: string | HtmlSafeString): DocumentFragment {\n  if (typeof html !== 'string') html = html.toString();\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return document.importNode(template.content, true);\n}\n\n/**\n * Like {@link parseHTML}, but returns an {@link Element} instead of a\n * {@link DocumentFragment}. If the HTML being parsed does not contain\n * exactly one element, an error is thrown.\n */\nexport function parseHTMLElement<T extends Element = Element>(\n  document: Document,\n  html: string | HtmlSafeString,\n): T {\n  const documentFragment = parseHTML(document, html);\n  if (documentFragment.childElementCount !== 1) {\n    throw new Error('Expected HTML to contain exactly one element');\n  }\n  return documentFragment.firstElementChild as T;\n}\n"]}