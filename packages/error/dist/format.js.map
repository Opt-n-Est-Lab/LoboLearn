{"version":3,"file":"format.js","sourceRoot":"","sources":["../src/format.ts"],"names":[],"mappings":"AAAA,SAAS,YAAY,CAAC,KAAa,EAAE,KAAa;IAChD,IAAI,KAAK,KAAK,CAAC;QAAE,OAAO,KAAK,CAAC;IAE9B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACpC,OAAO,KAAK;SACT,KAAK,CAAC,IAAI,CAAC;SACX,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC;SACxC,IAAI,CAAC,IAAI,CAAC,CAAC;AAChB,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,gBAAgB,CAAC,GAAQ,EAAE,KAAK,GAAG,CAAC,EAAE,MAAM,GAAG,EAAE;IAC/D,2EAA2E;IAC3E,IAAI,KAAK,GAAG,EAAE;QAAE,OAAO,KAAK,CAAC;IAE7B,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAEpD,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC;QACd,KAAK,IAAI,OAAO,gBAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;IACtE,CAAC;IAED,IAAI,GAAG,YAAY,cAAc,EAAE,CAAC;QAClC,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QACxC,KAAK,IAAI,OAAO,MAAM,aAAa,CAAC;QAEpC,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;YAC9B,KAAK,IAAI,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;YAC5C,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;gBAAE,KAAK,IAAI,MAAM,CAAC;QACjD,CAAC,CAAC,CAAC;QAEH,KAAK,IAAI,KAAK,MAAM,GAAG,CAAC;IAC1B,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB,CAAC,GAAQ;IAC3C,IAAI,CAAC;QACH,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAC/B,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,GAAG,CAAC,KAAK,CAAC;IACnB,CAAC;AACH,CAAC","sourcesContent":["function indentString(stack: string, depth: number) {\n  if (depth === 0) return stack;\n\n  const indent = '    '.repeat(depth);\n  return stack\n    .split('\\n')\n    .map((line) => (indent + line).trimEnd())\n    .join('\\n');\n}\n\n/**\n * Recursively formats an error into a string. Correctly handles both the\n * `.cause` property and `AggregateError` instances.\n */\nexport function formatErrorStack(err: any, depth = 0, prefix = ''): string {\n  // This will handle both circular references and unnecessarily deep chains.\n  if (depth > 10) return '...';\n\n  let stack = indentString(prefix + err.stack, depth);\n\n  if (err.cause) {\n    stack += `\\n\\n${formatErrorStack(err.cause, depth + 1, 'Cause: ')}`;\n  }\n\n  if (err instanceof AggregateError) {\n    const indent = '    '.repeat(depth + 1);\n    stack += `\\n\\n${indent}Errors: [\\n`;\n\n    err.errors.forEach((error, i) => {\n      stack += formatErrorStack(error, depth + 2);\n      if (i < err.errors.length - 1) stack += '\\n\\n';\n    });\n\n    stack += `\\n${indent}]`;\n  }\n\n  return stack;\n}\n\n/**\n * This is a version of {@link formatErrorStack} that won't error in the case\n * of an unexpected error object. We'll use the original function if it works,\n * but if it fails for any reason, we'll just return the plain stack, whatever\n * it might be.\n */\nexport function formatErrorStackSafe(err: any): string {\n  try {\n    return formatErrorStack(err);\n  } catch {\n    return err.stack;\n  }\n}\n"]}