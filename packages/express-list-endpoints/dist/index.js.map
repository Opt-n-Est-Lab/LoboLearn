{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Express, Router } from 'express';\n\ninterface Route {\n  methods: object;\n  path: string | string[];\n  stack: any[];\n}\n\nexport interface Endpoint {\n  path: string;\n  methods: string[];\n  middlewares: string[];\n}\n\nconst regExpToParseExpressPathRegExp =\n  /^\\/\\^\\\\?\\/?(?:(:?[\\w\\\\.-]*(?:\\\\\\/:?[\\w\\\\.-]*)*)|(\\(\\?:\\\\?\\/?\\([^)]+\\)\\)))\\\\\\/.*/;\nconst regExpToReplaceExpressPathRegExpParams = /\\(\\?:\\\\?\\/?\\([^)]+\\)\\)/;\nconst regexpExpressParamRegexp = /\\(\\?:\\\\?\\\\?\\/?\\([^)]+\\)\\)/g;\nconst regexpExpressPathParamRegexp = /(:[^)]+)\\([^)]+\\)/g;\n\nconst EXPRESS_ROOT_PATH_REGEXP_VALUE = '/^\\\\/?(?=\\\\/|$)/i';\nconst STACK_ITEM_VALID_NAMES = ['router', 'bound dispatch', 'mounted_app'];\n\n/**\n * Returns all the verbs detected for the passed route\n */\nfunction getRouteMethods(route: Route) {\n  let methods = Object.keys(route.methods);\n\n  methods = methods.filter((method) => method !== '_all');\n  methods = methods.map((method) => method.toUpperCase());\n\n  return methods;\n}\n\n/**\n * Returns the names (or anonymous) of all the middlewares attached to the\n * passed route.\n */\nfunction getRouteMiddlewares(route: Route): string[] {\n  return route.stack.map((item) => {\n    return item.handle.name || 'anonymous';\n  });\n}\n\n/**\n * Returns true if found regexp related with express params.\n */\nfunction hasParams(expressPathRegExp: string): boolean {\n  return regexpExpressParamRegexp.test(expressPathRegExp);\n}\n\n/**\n * @param route Express route object to be parsed\n * @param basePath The basePath the route is on\n * @return Endpoints info\n */\nfunction parseExpressRoute(route: Route, basePath: string): Endpoint[] {\n  const paths = [];\n\n  if (Array.isArray(route.path)) {\n    paths.push(...route.path);\n  } else {\n    paths.push(route.path);\n  }\n\n  const endpoints: Endpoint[] = paths.map((path) => {\n    const completePath = basePath && path === '/' ? basePath : `${basePath}${path}`;\n\n    const endpoint: Endpoint = {\n      path: completePath.replace(regexpExpressPathParamRegexp, '$1'),\n      methods: getRouteMethods(route),\n      middlewares: getRouteMiddlewares(route),\n    };\n\n    return endpoint;\n  });\n\n  return endpoints;\n}\n\nfunction parseExpressPath(expressPathRegExp: RegExp, params: any[]): string {\n  let parsedRegExp = expressPathRegExp.toString();\n  let expressPathRegExpExec = regExpToParseExpressPathRegExp.exec(parsedRegExp);\n  let paramIndex = 0;\n\n  while (hasParams(parsedRegExp)) {\n    const paramName = params[paramIndex].name;\n    const paramId = `:${paramName}`;\n\n    parsedRegExp = parsedRegExp.replace(regExpToReplaceExpressPathRegExpParams, (str) => {\n      // Express >= 4.20.0 uses a different RegExp for parameters: it\n      // captures the slash as part of the parameter. We need to check\n      // for this case and add the slash to the value that will replace\n      // the parameter in the path.\n      if (str.startsWith('(?:\\\\/')) {\n        return `\\\\/${paramId}`;\n      }\n\n      return paramId;\n    });\n\n    paramIndex++;\n  }\n\n  if (parsedRegExp !== expressPathRegExp.toString()) {\n    expressPathRegExpExec = regExpToParseExpressPathRegExp.exec(parsedRegExp);\n  }\n\n  // TODO: can we do better than this?\n  if (!expressPathRegExpExec) {\n    throw new Error('Error parsing express path');\n  }\n\n  const parsedPath = expressPathRegExpExec[1].replace(/\\\\\\//g, '/');\n\n  return parsedPath;\n}\n\nfunction parseEndpoints(\n  app: Express | Router | any,\n  basePath?: string,\n  endpoints?: Endpoint[],\n): Endpoint[] {\n  const stack = app.stack || (app._router && app._router.stack);\n\n  endpoints = endpoints || [];\n  basePath = basePath || '';\n\n  if (!stack) {\n    if (endpoints.length) {\n      endpoints = addEndpoints(endpoints, [\n        {\n          path: basePath,\n          methods: [],\n          middlewares: [],\n        },\n      ]);\n    }\n  } else {\n    endpoints = parseStack(stack, basePath, endpoints);\n  }\n\n  return endpoints;\n}\n\n/**\n * Ensures the path of the new endpoints isn't yet in the array.\n * If the path is already in the array merges the endpoints with the existing\n * one, if not, it adds them to the array.\n *\n * @param currentEndpoints Array of current endpoints\n * @param endpointsToAdd New endpoints to be added to the array\n * @returns Updated endpoints array\n */\nfunction addEndpoints(currentEndpoints: Endpoint[], endpointsToAdd: Endpoint[]): Endpoint[] {\n  endpointsToAdd.forEach((newEndpoint) => {\n    const existingEndpoint = currentEndpoints.find(\n      (endpoint) => endpoint.path === newEndpoint.path,\n    );\n\n    if (existingEndpoint !== undefined) {\n      const newMethods = newEndpoint.methods.filter(\n        (method) => !existingEndpoint.methods.includes(method),\n      );\n\n      existingEndpoint.methods = existingEndpoint.methods.concat(newMethods);\n    } else {\n      currentEndpoints.push(newEndpoint);\n    }\n  });\n\n  return currentEndpoints;\n}\n\nfunction parseStack(stack: any[], basePath: string, endpoints: Endpoint[]): Endpoint[] {\n  stack.forEach((stackItem) => {\n    if (stackItem.route) {\n      const newEndpoints = parseExpressRoute(stackItem.route, basePath);\n\n      endpoints = addEndpoints(endpoints, newEndpoints);\n    } else if (STACK_ITEM_VALID_NAMES.includes(stackItem.name)) {\n      const isExpressPathRegexp = regExpToParseExpressPathRegExp.test(stackItem.regexp);\n\n      let newBasePath = basePath;\n\n      if (isExpressPathRegexp) {\n        const parsedPath = parseExpressPath(stackItem.regexp, stackItem.keys);\n\n        newBasePath += `/${parsedPath}`;\n      } else if (\n        !stackItem.path &&\n        stackItem.regexp &&\n        stackItem.regexp.toString() !== EXPRESS_ROOT_PATH_REGEXP_VALUE\n      ) {\n        const regExpPath = ` RegExp(${stackItem.regexp}) `;\n\n        newBasePath += `/${regExpPath}`;\n      }\n\n      endpoints = parseEndpoints(stackItem.handle, newBasePath, endpoints);\n    }\n  });\n\n  return endpoints;\n}\n\n/**\n * Returns an array of strings with all the detected endpoints\n * @param app The express/router instance to get the endpoints from\n * @returns The array of endpoints\n */\nfunction expressListEndpoints(app: Express | Router | any): Endpoint[] {\n  const endpoints = parseEndpoints(app);\n\n  return endpoints;\n}\n\nexport default expressListEndpoints;\n"]}