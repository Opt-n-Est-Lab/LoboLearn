{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Element, Root as HastRoot } from 'hast';\nimport type { Root as MdastRoot, Text } from 'mdast';\nimport type { InlineMath, Math } from 'mdast-util-math';\nimport rehypeRaw from 'rehype-raw';\nimport rehypeSanitize from 'rehype-sanitize';\nimport rehypeStringify from 'rehype-stringify';\nimport remarkGfm from 'remark-gfm';\nimport remarkMath from 'remark-math';\nimport remarkParse from 'remark-parse';\nimport remark2rehype from 'remark-rehype';\nimport { type Processor, type TransformCallback, type Transformer, unified } from 'unified';\nimport type { Node } from 'unist';\nimport { visit } from 'unist-util-visit';\nimport type { VFile } from 'vfile';\n\n/**\n * This visitor is used for inline markdown processing, particularly for cases where the result is\n * expected to be shown in a single line without a block. In essence, if the result of the\n * conversion contains a single paragraph (`p`) with some content, it replaces the paragraph itself\n * with the content of the paragraph.\n */\nfunction visitCheckSingleParagraph(ast: HastRoot) {\n  return visit(ast, 'root', (node) => {\n    if (node.children.length === 1) {\n      const child = node.children[0] as Element;\n      if (child.tagName === 'p') {\n        node.children = child.children;\n      }\n    }\n  });\n}\n\n/**\n * By default, `remark-math` installs compilers to transform the AST back into\n * HTML, which ends up wrapping the math in unwanted spans and divs. Since all\n * math will be rendered on the client, we have our own visitor that will replace\n * any `math` or `inlineMath` nodes with raw text values wrapped in the appropriate\n * fences.\n */\nfunction visitMathBlock(ast: MdastRoot) {\n  return visit(ast, ['math', 'inlineMath'], (node, index, parent) => {\n    const startFence = node.type === 'math' ? '$$\\n' : '$';\n    const endFence = node.type === 'math' ? '\\n$$' : '$';\n    const text: Text = {\n      type: 'text',\n      value: startFence + (node as Math | InlineMath).value + endFence,\n    };\n    parent?.children.splice(index ?? 0, 1, text);\n  });\n}\n\nfunction makeHandler<R extends Node>(visitor: (ast: R) => undefined): () => Transformer<R, R> {\n  return () => (ast: R, vFile: VFile, callback?: TransformCallback<R>) => {\n    visitor(ast);\n\n    if (typeof callback === 'function') {\n      return callback(undefined, ast, vFile);\n    }\n    return ast;\n  };\n}\n\nexport function createProcessor({\n  mdastVisitors,\n  hastVisitors,\n  sanitize = true,\n}: {\n  mdastVisitors?: ((ast: MdastRoot) => undefined)[];\n  hastVisitors?: ((ast: HastRoot) => undefined)[];\n  sanitize?: boolean;\n} = {}) {\n  const htmlConversion = (mdastVisitors ?? [])\n    .reduce<Processor<MdastRoot, MdastRoot, MdastRoot | undefined>>(\n      (processor, visitor) => processor.use(makeHandler(visitor)),\n      unified().use(remarkParse).use(remarkMath),\n    )\n    .use(makeHandler(visitMathBlock))\n    .use(remarkGfm)\n    .use(remark2rehype, { allowDangerousHtml: true })\n    .use(rehypeRaw);\n  return (hastVisitors ?? [])\n    .reduce(\n      (processor, visitor) => processor.use(makeHandler(visitor)),\n      sanitize ? htmlConversion.use(rehypeSanitize) : htmlConversion,\n    )\n    .use(rehypeStringify);\n}\n\nconst defaultProcessor = createProcessor();\nconst inlineProcessor = createProcessor({ hastVisitors: [visitCheckSingleParagraph] });\n\n/**\n * Converts markdown to HTML. If `inline` is true, and the result fits a single\n * paragraph, the content is returned inline without the paragraph tag.\n */\nexport async function markdownToHtml(original: string, { inline }: { inline?: boolean } = {}) {\n  return (await (inline ? inlineProcessor : defaultProcessor).process(original)).value.toString();\n}\n"]}