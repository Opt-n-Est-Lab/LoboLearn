{"version":3,"file":"describe.js","sourceRoot":"","sources":["../src/describe.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport { parse as parsePostgresArray } from 'postgres-array';\n\nimport { PostgresPool, loadSqlEquiv } from '@prairielearn/postgres';\n\nconst sql = loadSqlEquiv(import.meta.url);\n\ninterface ColumnDescription {\n  name: string;\n  type: string;\n  notnull: boolean;\n  default: any;\n}\n\ninterface IndexDescription {\n  name: string;\n  isprimary: boolean;\n  isunique: boolean;\n  indexdef: string;\n  constraintdef: string;\n  contype: string;\n}\n\ninterface ForeignKeyConstraintDescription {\n  name: string;\n  def: string;\n}\n\ninterface ReferenceDescription {\n  name: string;\n  table: string;\n  condef: string;\n}\n\ninterface CheckConstraintDescription {\n  name: string;\n  def: string;\n}\n\ninterface TableDescription {\n  columns: ColumnDescription[];\n  indexes: IndexDescription[];\n  foreignKeyConstraints: ForeignKeyConstraintDescription[];\n  references: ReferenceDescription[];\n  checkConstraints: CheckConstraintDescription[];\n}\n\nexport interface DatabaseDescription {\n  tables: Record<string, TableDescription>;\n  enums: Record<string, string[]>;\n}\n\ninterface DescribeOptions {\n  ignoreTables?: string[];\n  ignoreColumns?: string[];\n  ignoreEnums?: string[];\n}\n\nasync function describeWithPool(\n  pool: PostgresPool,\n  options: DescribeOptions,\n): Promise<DatabaseDescription> {\n  const ignoreTables = options?.ignoreTables || [];\n  const ignoreEnums = options?.ignoreEnums || [];\n  let ignoreColumns: Record<string, string[]> = {};\n\n  const output: DatabaseDescription = {\n    tables: {},\n    enums: {},\n  };\n\n  // Get the names of the tables and filter out any ignored tables\n  const tablesRes = await pool.queryAsync(sql.get_tables, []);\n  const tables = tablesRes.rows.filter((table) => ignoreTables.indexOf(table.name) === -1);\n\n  // Transform ignored columns into a map from table names to arrays\n  // of column names\n  if (options.ignoreColumns && Array.isArray(options.ignoreColumns)) {\n    ignoreColumns = options.ignoreColumns\n      .filter((ignore) => {\n        return /^[^\\s.]*\\.[^\\s.]*$/.test(ignore);\n      })\n      .reduce(\n        (result, value) => {\n          const res = /^(([^\\s.]*)\\.([^\\s.]*))$/.exec(value);\n          if (!res) {\n            throw new Error(`Invalid ignore column: ${value}`);\n          }\n          const table = res[2];\n          const column = res[3];\n          (result[table] || (result[table] = [])).push(column);\n          return result;\n        },\n        {} as Record<string, string[]>,\n      );\n  }\n\n  // Get column info for each table\n  for (const table of tables) {\n    const columnResults = await pool.queryAsync(sql.get_columns_for_table, {\n      oid: table.oid,\n    });\n\n    const columns = columnResults.rows.filter((row) => {\n      return (ignoreColumns[table.name] || []).indexOf(row.name) === -1;\n    });\n\n    const indexResults = await pool.queryAsync(sql.get_indexes_for_table, {\n      oid: table.oid,\n    });\n\n    const foreignKeyConstraintResults = await pool.queryAsync(\n      sql.get_foreign_key_constraints_for_table,\n      {\n        oid: table.oid,\n      },\n    );\n\n    const referenceResults = await pool.queryAsync(sql.get_references_for_table, {\n      oid: table.oid,\n    });\n\n    // Filter out references from ignored tables\n    const references = referenceResults.rows.filter((row) => {\n      return ignoreTables.indexOf(row.table) === -1;\n    });\n\n    const checkConstraintResults = await pool.queryAsync(sql.get_check_constraints_for_table, {\n      oid: table.oid,\n    });\n\n    output.tables[table.name] = {\n      columns,\n      indexes: indexResults.rows,\n      foreignKeyConstraints: foreignKeyConstraintResults.rows,\n      references,\n      checkConstraints: checkConstraintResults.rows,\n    };\n  }\n\n  // Get all enums\n  const enumsRes = await pool.queryAsync(sql.get_enums, []);\n\n  // Filter ignored enums\n  const rows = enumsRes.rows.filter((row) => {\n    return ignoreEnums.indexOf(row.name) === -1;\n  });\n\n  rows.forEach((row) => {\n    output.enums[row.name] = parsePostgresArray(row.values);\n  });\n\n  return output;\n}\n\n/**\n * Will produce a description of a given database's schema. This will include\n * information about tables, enums, constraints, indices, etc.\n */\nexport async function describeDatabase(\n  databaseName: string,\n  options: DescribeOptions = {},\n): Promise<DatabaseDescription> {\n  // Connect to the database.\n  const pool = new PostgresPool();\n  const pgConfig = {\n    user: 'postgres',\n    database: databaseName,\n    host: 'localhost',\n    max: 10,\n    idleTimeoutMillis: 30000,\n  };\n  function idleErrorHandler(err: Error) {\n    throw err;\n  }\n  await pool.initAsync(pgConfig, idleErrorHandler);\n\n  try {\n    return await describeWithPool(pool, options);\n  } finally {\n    await pool.closeAsync();\n  }\n}\n\nexport function formatDatabaseDescription(\n  description: DatabaseDescription,\n  options = { coloredOutput: true },\n): { tables: Record<string, string>; enums: Record<string, string> } {\n  const output = {\n    tables: {} as Record<string, string>,\n    enums: {} as Record<string, string>,\n  };\n\n  Object.keys(description.tables).forEach((tableName) => (output.tables[tableName] = ''));\n\n  /**\n   * Optionally applies the given formatter to the text if colored output is\n   * enabled.\n   */\n  function formatText(text: string, formatter: (s: string) => string): string {\n    if (options.coloredOutput) {\n      return formatter(text);\n    }\n    return text;\n  }\n\n  Object.entries(description.tables).forEach(([tableName, table]) => {\n    if (table.columns.length > 0) {\n      output.tables[tableName] += formatText('columns\\n', chalk.underline);\n      output.tables[tableName] += table.columns\n        .map((row) => {\n          let rowText = formatText(`    ${row.name}`, chalk.bold);\n          rowText += ':' + formatText(` ${row.type}`, chalk.green);\n          if (row.notnull) {\n            rowText += formatText(' not null', chalk.gray);\n          }\n          if (row.default) {\n            rowText += formatText(` default ${row.default}`, chalk.gray);\n          }\n          return rowText;\n        })\n        .join('\\n');\n    }\n\n    if (table.indexes.length > 0) {\n      if (output.tables[tableName].length !== 0) {\n        output.tables[tableName] += '\\n\\n';\n      }\n      output.tables[tableName] += formatText('indexes\\n', chalk.underline);\n      output.tables[tableName] += table.indexes\n        .map((row) => {\n          const using = row.indexdef.substring(row.indexdef.indexOf('USING '));\n          let rowText = formatText(`    ${row.name}`, chalk.bold) + ':';\n          // Primary indexes are implicitly unique, so we don't need to\n          // capture that explicitly.\n          if (row.isunique && !row.isprimary) {\n            if (!row.constraintdef || row.constraintdef.indexOf('UNIQUE') === -1) {\n              // Some unique indexes don't include the UNIQUE constraint\n              // as part of the constraint definition, so we need to capture\n              // that manually.\n              rowText += formatText(' UNIQUE', chalk.green);\n            }\n          }\n          rowText += row.constraintdef ? formatText(` ${row.constraintdef}`, chalk.green) : '';\n          rowText += using ? formatText(` ${using}`, chalk.green) : '';\n          return rowText;\n        })\n        .join('\\n');\n    }\n\n    if (table.checkConstraints.length > 0) {\n      if (output.tables[tableName].length !== 0) {\n        output.tables[tableName] += '\\n\\n';\n      }\n      output.tables[tableName] += formatText('check constraints\\n', chalk.underline);\n      output.tables[tableName] += table.checkConstraints\n        .map((row) => {\n          // Particularly long constraints are formatted as multiple lines.\n          // We'll collapse them into a single line for better appearance in\n          // the resulting file.\n          //\n          // The first replace handles lines that end with a parenthesis: we\n          // want to avoid spaces between the parenthesis and the next token.\n          //\n          // The second replace handles all other lines: we want to collapse\n          // all leading whitespace into a single space.\n          const def = row.def.replace(/\\(\\n/g, '(').replace(/\\n\\s*/g, ' ');\n\n          let rowText = formatText(`    ${row.name}:`, chalk.bold);\n          rowText += formatText(` ${def}`, chalk.green);\n          return rowText;\n        })\n        .join('\\n');\n    }\n\n    if (table.foreignKeyConstraints.length > 0) {\n      if (output.tables[tableName].length !== 0) {\n        output.tables[tableName] += '\\n\\n';\n      }\n      output.tables[tableName] += formatText('foreign-key constraints\\n', chalk.underline);\n      output.tables[tableName] += table.foreignKeyConstraints\n        .map((row) => {\n          let rowText = formatText(`    ${row.name}:`, chalk.bold);\n          rowText += formatText(` ${row.def}`, chalk.green);\n          return rowText;\n        })\n        .join('\\n');\n    }\n\n    if (table.references.length > 0) {\n      if (output.tables[tableName].length !== 0) {\n        output.tables[tableName] += '\\n\\n';\n      }\n      output.tables[tableName] += formatText('referenced by\\n', chalk.underline);\n      output.tables[tableName] += table.references\n        ?.map((row) => {\n          let rowText = formatText(`    ${row.table}:`, chalk.bold);\n          rowText += formatText(` ${row.condef}`, chalk.green);\n          return rowText;\n        })\n        .join('\\n');\n    }\n  });\n\n  Object.entries(description.enums).forEach(([enumName, enumValues]) => {\n    output.enums[enumName] = formatText(enumValues.join(', '), chalk.gray);\n  });\n\n  // We need to tack on a newline to everything.\n  Object.entries(output.tables).forEach(([tableName, table]) => {\n    output.tables[tableName] = table + '\\n';\n  });\n  Object.entries(output.enums).forEach(([enumName, enumValues]) => {\n    output.enums[enumName] = enumValues + '\\n';\n  });\n\n  return output;\n}\n"]}