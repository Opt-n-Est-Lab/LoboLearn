{"version":3,"file":"pool.js","sourceRoot":"","sources":["../src/pool.ts"],"names":[],"mappings":"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","sourcesContent":["import { AsyncLocalStorage } from 'node:async_hooks';\nimport { Readable, Transform } from 'node:stream';\nimport { callbackify } from 'node:util';\n\nimport debugfn from 'debug';\nimport _ from 'lodash';\nimport multipipe from 'multipipe';\nimport pg, { type QueryResult } from 'pg';\nimport Cursor from 'pg-cursor';\nimport { DatabaseError } from 'pg-protocol';\nimport { z } from 'zod';\n\nexport type QueryParams = Record<string, any> | any[];\n\nexport interface CursorIterator<T> {\n  iterate: (batchSize: number) => AsyncGenerator<T[]>;\n  stream: (batchSize: number) => NodeJS.ReadWriteStream;\n}\n\nexport interface PostgresPoolConfig extends pg.PoolConfig {\n  errorOnUnusedParameters?: boolean;\n}\n\nconst debug = debugfn('@prairielearn/postgres');\nconst lastQueryMap = new WeakMap<pg.PoolClient, string>();\nconst searchSchemaMap = new WeakMap<pg.PoolClient, string>();\n\nfunction addDataToError(err: Error, data: Record<string, any>): Error {\n  (err as any).data = {\n    ...((err as any).data ?? {}),\n    ...data,\n  };\n  return err;\n}\n\nexport class PostgresError extends Error {\n  public data: Record<string, any>;\n\n  constructor(message: string, data: Record<string, any>) {\n    super(message);\n    this.data = data;\n    this.name = 'PostgresError';\n  }\n}\n\n/**\n * Formats a string for debugging.\n */\nfunction debugString(s: string): string {\n  if (typeof s !== 'string') return 'NOT A STRING';\n  s = s.replace(/\\n/g, '\\\\n');\n  if (s.length > 78) s = s.substring(0, 75) + '...';\n  s = '\"' + s + '\"';\n  return s;\n}\n\n/**\n * Formats a set of params for debugging.\n */\nfunction debugParams(params: QueryParams): string {\n  let s;\n  try {\n    s = JSON.stringify(params);\n  } catch {\n    s = 'CANNOT JSON STRINGIFY';\n  }\n  return debugString(s);\n}\n\n/**\n * Given an SQL string and params, creates an array of params and an SQL string\n * with any named dollar-sign placeholders replaced with parameters.\n */\nfunction paramsToArray(\n  sql: string,\n  params: QueryParams,\n  errorOnUnusedParameters: boolean,\n): { processedSql: string; paramsArray: any } {\n  if (typeof sql !== 'string') throw new Error('SQL must be a string');\n  if (Array.isArray(params)) {\n    return {\n      processedSql: sql,\n      paramsArray: params,\n    };\n  }\n  if (params == null || typeof params !== 'object') {\n    throw new Error('params must be array or object');\n  }\n\n  const re = /\\$([-_a-zA-Z0-9]+)/;\n  let result;\n  let processedSql = '';\n  let remainingSql = sql;\n  let nParams = 0;\n  const map: Record<string, string> = {};\n  let paramsArray: any[] = [];\n  while ((result = re.exec(remainingSql)) !== null) {\n    const v = result[1];\n    if (!(v in map)) {\n      if (!(v in params)) throw new Error(`Missing parameter: ${v}`);\n      if (Array.isArray(params[v])) {\n        map[v] = 'ARRAY[' + params[v].map((_, n) => '$' + (n + nParams + 1)).join(',') + ']';\n        nParams += params[v].length;\n        paramsArray = paramsArray.concat(params[v]);\n      } else {\n        nParams++;\n        map[v] = '$' + nParams;\n        paramsArray.push(params[v]);\n      }\n    }\n    processedSql += remainingSql.substring(0, result.index) + map[v];\n    remainingSql = remainingSql.substring(result.index + result[0].length);\n  }\n  processedSql += remainingSql;\n  remainingSql = '';\n  if (errorOnUnusedParameters) {\n    const difference = _.difference(Object.keys(params), Object.keys(map));\n    if (difference.length) {\n      throw new Error(`Unused parameters in SQL query: ${JSON.stringify(difference)}`);\n    }\n  }\n  return { processedSql, paramsArray };\n}\n\n/**\n * Escapes the given identifier for use in an SQL query. Useful for preventing\n * SQL injection.\n */\nfunction escapeIdentifier(identifier: string): string {\n  // Note that as of 2021-06-29 escapeIdentifier() is undocumented. See:\n  // https://github.com/brianc/node-postgres/pull/396\n  // https://github.com/brianc/node-postgres/issues/1978\n  // https://www.postgresql.org/docs/current/sql-syntax-lexical.html\n  return pg.Client.prototype.escapeIdentifier(identifier);\n}\n\nfunction enhanceError(err: Error, sql: string, params: QueryParams): Error {\n  // Copy the error so we don't end up with a circular reference in the\n  // final error.\n  const sqlError = { ...err };\n\n  // `message` is a non-enumerable property, so we need to copy it manually to\n  // the error object.\n  sqlError.message = err.message;\n\n  const errorHasPosition = err instanceof DatabaseError && err.position != null;\n\n  return addDataToError(err, {\n    sqlError,\n    // If the error has a `position` field, we need to use the processed source\n    // (where e.g. `$foobar` has been replaced with `$1`) so that the position\n    // is accurate.\n    sql: errorHasPosition ? paramsToArray(sql, params, false).processedSql : sql,\n    sqlParams: params,\n  });\n}\n\nexport class PostgresPool {\n  /** The pool from which clients will be acquired. */\n  private pool: pg.Pool | null = null;\n  /**\n   * We use this to propagate the client associated with the current transaction\n   * to any nested queries. In the past, we had some nasty bugs associated with\n   * the fact that we tried to acquire new clients inside of transactions, which\n   * ultimately lead to a deadlock.\n   */\n  private alsClient = new AsyncLocalStorage<pg.PoolClient>();\n  private searchSchema: string | null = null;\n  /** Tracks the total number of queries executed by this pool. */\n  private _queryCount = 0;\n  private errorOnUnusedParameters = false;\n\n  /**\n   * Creates a new connection pool and attempts to connect to the database.\n   */\n  async initAsync(\n    pgConfig: PostgresPoolConfig,\n    idleErrorHandler: (error: Error, client: pg.PoolClient) => void,\n  ): Promise<void> {\n    this.errorOnUnusedParameters = pgConfig.errorOnUnusedParameters ?? false;\n    this.pool = new pg.Pool(pgConfig);\n    this.pool.on('error', function (err, client) {\n      const lastQuery = lastQueryMap.get(client);\n      idleErrorHandler(addDataToError(err, { lastQuery }), client);\n    });\n    this.pool.on('connect', (client) => {\n      client.on('error', (err) => {\n        const lastQuery = lastQueryMap.get(client);\n        idleErrorHandler(addDataToError(err, { lastQuery }), client);\n      });\n    });\n    this.pool.on('remove', (client) => {\n      // This shouldn't be necessary, as `pg` currently allows clients to be\n      // garbage collected after they're removed. However, if `pg` someday\n      // starts reusing client objects across difference connections, this\n      // will ensure that we re-set the search path when the client reconnects.\n      searchSchemaMap.delete(client);\n    });\n\n    // Attempt to connect to the database so that we can fail quickly if\n    // something isn't configured correctly.\n    let retryCount = 0;\n    const retryTimeouts = [500, 1000, 2000, 5000, 10000];\n    while (retryCount <= retryTimeouts.length) {\n      try {\n        const client = await this.pool.connect();\n        client.release();\n        return;\n      } catch (err: any) {\n        if (retryCount === retryTimeouts.length) {\n          throw new Error(\n            `Could not connect to Postgres after ${retryTimeouts.length} attempts: ${err.message}`,\n          );\n        }\n\n        const timeout = retryTimeouts[retryCount];\n        retryCount++;\n        await new Promise((resolve) => setTimeout(resolve, timeout));\n      }\n    }\n  }\n\n  /**\n   * Creates a new connection pool and attempts to connect to the database.\n   */\n  init = callbackify(this.initAsync);\n\n  /**\n   * Closes the connection pool.\n   */\n  async closeAsync(): Promise<void> {\n    if (!this.pool) return;\n    await this.pool.end();\n    this.pool = null;\n  }\n\n  /**\n   * Closes the connection pool.\n   */\n  close = callbackify(this.closeAsync);\n\n  /**\n   * Gets a new client from the connection pool. If `err` is not null\n   * then `client` and `done` are undefined. If `err` is null then\n   * `client` is valid and can be used. The caller MUST call `done()` to\n   * release the client, whether or not errors occurred while using\n   * `client`. The client can call `done(truthy_value)` to force\n   * destruction of the client, but this should not be used except in\n   * unusual circumstances.\n   */\n  async getClientAsync(): Promise<pg.PoolClient> {\n    if (!this.pool) {\n      throw new Error('Connection pool is not open');\n    }\n\n    // If we're inside a transaction, we'll reuse the same client to avoid a\n    // potential deadlock.\n    const client = this.alsClient.getStore() ?? (await this.pool.connect());\n\n    // If we're configured to use a particular schema, we'll store whether or\n    // not the search path has already been configured for this particular\n    // client. If we acquire a client and it's already had its search path\n    // set, we can avoid setting it again since the search path will persist\n    // for the life of the client.\n    //\n    // We do this check for each call to `getClient` instead of on\n    // `pool.connect` so that we don't have to be really careful about\n    // destroying old clients that were created before `setSearchSchema` was\n    // called. Instead, we'll just check if the search path matches the\n    // currently-desired schema, and if it's a mismatch (or doesn't exist\n    // at all), we re-set it for the current client.\n    //\n    // Note that this accidentally supports changing the search_path on the fly,\n    // although that's not something we currently do (or would be likely to do).\n    // It does NOT support clearing the existing search schema - e.g.,\n    // `setSearchSchema(null)` would not work as you expect. This is fine, as\n    // that's not something we ever do in practice.\n    const clientSearchSchema = searchSchemaMap.get(client);\n    if (this.searchSchema != null && clientSearchSchema !== this.searchSchema) {\n      const setSearchPathSql = `SET search_path TO ${escapeIdentifier(this.searchSchema)},public`;\n      try {\n        await this.queryWithClientAsync(client, setSearchPathSql, {});\n      } catch (err) {\n        client.release();\n        throw err;\n      }\n      searchSchemaMap.set(client, this.searchSchema);\n    }\n\n    return client;\n  }\n\n  /**\n   * Gets a new client from the connection pool.\n   */\n  getClient(callback: (error: Error | null, client?: pg.PoolClient, done?: () => void) => void) {\n    this.getClientAsync()\n      .then((client) => callback(null, client, client.release))\n      .catch((err) => callback(err));\n  }\n\n  /**\n   * Performs a query with the given client.\n   */\n  async queryWithClientAsync(\n    client: pg.PoolClient,\n    sql: string,\n    params: QueryParams,\n  ): Promise<pg.QueryResult> {\n    this._queryCount += 1;\n    debug('queryWithClient()', 'sql:', debugString(sql));\n    debug('queryWithClient()', 'params:', debugParams(params));\n    const { processedSql, paramsArray } = paramsToArray(sql, params, this.errorOnUnusedParameters);\n    try {\n      lastQueryMap.set(client, processedSql);\n      const result = await client.query(processedSql, paramsArray);\n      debug('queryWithClient() success', 'rowCount:', result.rowCount);\n      return result;\n    } catch (err: any) {\n      throw enhanceError(err, sql, params);\n    }\n  }\n\n  /**\n   * Performs a query with the given client.\n   */\n  queryWithClient = callbackify(this.queryWithClientAsync);\n\n  /**\n   * Performs a query with the given client. Errors if the query returns more\n   * than one row.\n   */\n  async queryWithClientOneRowAsync(\n    client: pg.PoolClient,\n    sql: string,\n    params: QueryParams,\n  ): Promise<pg.QueryResult> {\n    debug('queryWithClientOneRow()', 'sql:', debugString(sql));\n    debug('queryWithClientOneRow()', 'params:', debugParams(params));\n    const result = await this.queryWithClientAsync(client, sql, params);\n    if (result.rowCount !== 1) {\n      throw new PostgresError(`Incorrect rowCount: ${result.rowCount}`, {\n        sql,\n        sqlParams: params,\n        result,\n      });\n    }\n    debug('queryWithClientOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Performs a query with the given client. Errors if the query returns more\n   * than one row.\n   */\n  queryWithClientOneRow = callbackify(this.queryWithClientOneRowAsync);\n\n  /**\n   * Performs a query with the given client. Errors if the query returns more\n   * than one row.\n   */\n  async queryWithClientZeroOrOneRowAsync(\n    client: pg.PoolClient,\n    sql: string,\n    params: QueryParams,\n  ): Promise<QueryResult> {\n    debug('queryWithClientZeroOrOneRow()', 'sql:', debugString(sql));\n    debug('queryWithClientZeroOrOneRow()', 'params:', debugParams(params));\n    const result = await this.queryWithClientAsync(client, sql, params);\n    if (result.rowCount == null || result.rowCount > 1) {\n      throw new PostgresError(`Incorrect rowCount: ${result.rowCount}`, {\n        sql,\n        sqlParams: params,\n        result,\n      });\n    }\n    debug('queryWithClientZeroOrOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Performs a query with the given client. Errors if the query returns more\n   * than one row.\n   */\n  queryWithClientZeroOrOneRow = callbackify(this.queryWithClientZeroOrOneRowAsync);\n\n  /**\n   * Rolls back the current transaction for the given client.\n   */\n  async rollbackWithClientAsync(client: pg.PoolClient) {\n    debug('rollbackWithClient()');\n    // From https://node-postgres.com/features/transactions\n    try {\n      await client.query('ROLLBACK');\n      // Only release the client if we weren't already inside a transaction.\n      if (this.alsClient.getStore() === undefined) {\n        client.release();\n      }\n    } catch (err: any) {\n      // If there was a problem rolling back the query, something is\n      // seriously messed up. Return the error to the release() function to\n      // close & remove this client from the pool. If you leave a client in\n      // the pool with an unaborted transaction, weird and hard to diagnose\n      // problems might happen.\n      client.release(err);\n    }\n  }\n\n  /**\n   * Rolls back the current transaction for the given client.\n   */\n  rollbackWithClient(\n    client: pg.PoolClient,\n    _done: (release?: any) => void,\n    callback: (err: Error | null) => void,\n  ) {\n    // Note that we can't use `util.callbackify` here because this function\n    // has an additional unused `done` parameter for backwards compatibility.\n    this.rollbackWithClientAsync(client)\n      .then(() => callback(null))\n      .catch((err) => callback(err));\n  }\n\n  /**\n   * Begins a new transaction.\n   */\n  async beginTransactionAsync(): Promise<pg.PoolClient> {\n    debug('beginTransaction()');\n    const client = await this.getClientAsync();\n    try {\n      await this.queryWithClientAsync(client, 'START TRANSACTION;', {});\n      return client;\n    } catch (err) {\n      await this.rollbackWithClientAsync(client);\n      throw err;\n    }\n  }\n\n  /**\n   * Commits the transaction if err is null, otherwise rollbacks the transaction.\n   * Also releases the client.\n   */\n  async endTransactionAsync(client: pg.PoolClient, err: Error | null | undefined) {\n    debug('endTransaction()');\n    if (err) {\n      try {\n        await this.rollbackWithClientAsync(client);\n      } catch (rollbackErr: any) {\n        throw addDataToError(rollbackErr, { prevErr: err, rollback: 'fail' });\n      }\n\n      // Even though we successfully rolled back the transaction, there was\n      // still an error in the first place that necessitated a rollback. Re-throw\n      // that error here so that everything downstream of here will know about it.\n      throw addDataToError(err, { rollback: 'success' });\n    } else {\n      try {\n        await this.queryWithClientAsync(client, 'COMMIT', {});\n      } finally {\n        // Only release the client if we aren't nested inside another transaction.\n        if (this.alsClient.getStore() === undefined) {\n          client.release();\n        }\n      }\n    }\n  }\n\n  /**\n   * Commits the transaction if err is null, otherwise rollbacks the transaction.\n   * Also releases the client.\n   */\n  endTransaction(\n    client: pg.PoolClient,\n    _done: (rollback?: any) => void,\n    err: Error | null | undefined,\n    callback: (error: Error | null) => void,\n  ): void {\n    this.endTransactionAsync(client, err)\n      .then(() => callback(null))\n      .catch((error) => callback(error));\n  }\n\n  /**\n   * Runs the specified function inside of a transaction. The function will\n   * receive a database client as an argument, but it can also make queries\n   * as usual, and the correct client will be used automatically.\n   *\n   * The transaction will be rolled back if the function throws an error, and\n   * will be committed otherwise.\n   */\n  async runInTransactionAsync<T>(fn: (client: pg.PoolClient) => Promise<T>): Promise<T> {\n    // Check if we're already inside a transaction. If so, we won't start another one,\n    // as Postgres doesn't support nested transactions.\n    const client = this.alsClient.getStore();\n    const isNestedTransaction = client !== undefined;\n    const transactionClient = client ?? (await this.beginTransactionAsync());\n\n    let result: T;\n    try {\n      result = await this.alsClient.run(transactionClient, () => fn(transactionClient));\n    } catch (err: any) {\n      if (!isNestedTransaction) {\n        // If we're inside another transaction, we assume that the root transaction\n        // will catch this error and roll back the transaction.\n        await this.endTransactionAsync(transactionClient, err);\n      }\n      throw err;\n    }\n\n    if (!isNestedTransaction) {\n      // If we're inside another transaction; don't commit it prematurely. Allow\n      // the root transaction to commit it instead.\n      //\n      // Note that we don't invoke `endTransactionAsync` inside the `try` block\n      // because we don't want an error thrown by it to trigger *another* call\n      // to `endTransactionAsync` in the `catch` block.\n      await this.endTransactionAsync(transactionClient, null);\n    }\n\n    return result;\n  }\n\n  /**\n   * Executes a query with the specified parameters.\n   */\n  async queryAsync(sql: string, params: QueryParams): Promise<QueryResult> {\n    debug('query()', 'sql:', debugString(sql));\n    debug('query()', 'params:', debugParams(params));\n    const client = await this.getClientAsync();\n    try {\n      return await this.queryWithClientAsync(client, sql, params);\n    } finally {\n      // Only release if we aren't nested in a transaction.\n      if (this.alsClient.getStore() === undefined) {\n        client.release();\n      }\n    }\n  }\n\n  /**\n   * Executes a query with the specified parameters.\n   */\n  query = callbackify(this.queryAsync);\n\n  /**\n   * Executes a query with the specified parameters. Errors if the query does\n   * not return exactly one row.\n   */\n  async queryOneRowAsync(sql: string, params: QueryParams): Promise<pg.QueryResult> {\n    debug('queryOneRow()', 'sql:', debugString(sql));\n    debug('queryOneRow()', 'params:', debugParams(params));\n    const result = await this.queryAsync(sql, params);\n    if (result.rowCount !== 1) {\n      throw new PostgresError(`Incorrect rowCount: ${result.rowCount}`, {\n        sql,\n        sqlParams: params,\n      });\n    }\n    debug('queryOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Executes a query with the specified parameters. Errors if the query does\n   * not return exactly one row.\n   */\n  queryOneRow = callbackify(this.queryOneRowAsync);\n\n  /**\n   * Executes a query with the specified parameters. Errors if the query\n   * returns more than one row.\n   */\n  async queryZeroOrOneRowAsync(sql: string, params: QueryParams): Promise<pg.QueryResult> {\n    debug('queryZeroOrOneRow()', 'sql:', debugString(sql));\n    debug('queryZeroOrOneRow()', 'params:', debugParams(params));\n    const result = await this.queryAsync(sql, params);\n    if (result.rowCount == null || result.rowCount > 1) {\n      throw new PostgresError(`Incorrect rowCount: ${result.rowCount}`, {\n        sql,\n        sqlParams: params,\n      });\n    }\n    debug('queryZeroOrOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Executes a query with the specified parameters. Errors if the query\n   * returns more than one row.\n   */\n  queryZeroOrOneRow = callbackify(this.queryZeroOrOneRowAsync);\n\n  /**\n   * Calls the given function with the specified parameters.\n   */\n  async callAsync(functionName: string, params: any[]): Promise<pg.QueryResult> {\n    debug('call()', 'function:', functionName);\n    debug('call()', 'params:', debugParams(params));\n    const placeholders = params.map((_, v) => '$' + (v + 1)).join();\n    const sql = `SELECT * FROM ${escapeIdentifier(functionName)}(${placeholders});`;\n    const result = await this.queryAsync(sql, params);\n    debug('call() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls the given function with the specified parameters.\n   */\n  call = callbackify(this.callAsync);\n\n  /**\n   * Calls the given function with the specified parameters. Errors if the\n   * function does not return exactly one row.\n   */\n  async callOneRowAsync(functionName: string, params: any[]): Promise<pg.QueryResult> {\n    debug('callOneRow()', 'function:', functionName);\n    debug('callOneRow()', 'params:', debugParams(params));\n    const result = await this.callAsync(functionName, params);\n    if (result.rowCount !== 1) {\n      throw new PostgresError('Incorrect rowCount: ' + result.rowCount, {\n        functionName,\n        sqlParams: params,\n      });\n    }\n    debug('callOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls the given function with the specified parameters. Errors if the\n   * function does not return exactly one row.\n   */\n  callOneRow = callbackify(this.callOneRowAsync);\n\n  /**\n   * Calls the given function with the specified parameters. Errors if the\n   * function returns more than one row.\n   */\n  async callZeroOrOneRowAsync(functionName: string, params: any[]): Promise<pg.QueryResult> {\n    debug('callZeroOrOneRow()', 'function:', functionName);\n    debug('callZeroOrOneRow()', 'params:', debugParams(params));\n    const result = await this.callAsync(functionName, params);\n    if (result.rowCount == null || result.rowCount > 1) {\n      throw new PostgresError('Incorrect rowCount: ' + result.rowCount, {\n        functionName,\n        sqlParams: params,\n      });\n    }\n    debug('callZeroOrOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls the given function with the specified parameters. Errors if the\n   * function returns more than one row.\n   */\n  callZeroOrOneRow = callbackify(this.callZeroOrOneRowAsync);\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   */\n  async callWithClientAsync(\n    client: pg.PoolClient,\n    functionName: string,\n    params: any[],\n  ): Promise<pg.QueryResult> {\n    debug('callWithClient()', 'function:', functionName);\n    debug('callWithClient()', 'params:', debugParams(params));\n    const placeholders = params.map((_, v) => '$' + (v + 1)).join();\n    const sql = `SELECT * FROM ${escapeIdentifier(functionName)}(${placeholders})`;\n    const result = await this.queryWithClientAsync(client, sql, params);\n    debug('callWithClient() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   */\n  callWithClient = callbackify(this.callWithClientAsync);\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   * Errors if the function does not return exactly one row.\n   */\n  async callWithClientOneRowAsync(\n    client: pg.PoolClient,\n    functionName: string,\n    params: any[],\n  ): Promise<pg.QueryResult> {\n    debug('callWithClientOneRow()', 'function:', functionName);\n    debug('callWithClientOneRow()', 'params:', debugParams(params));\n    const result = await this.callWithClientAsync(client, functionName, params);\n    if (result.rowCount !== 1) {\n      throw new PostgresError('Incorrect rowCount: ' + result.rowCount, {\n        functionName,\n        sqlParams: params,\n      });\n    }\n    debug('callWithClientOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   * Errors if the function does not return exactly one row.\n   */\n  callWithClientOneRow = callbackify(this.callWithClientOneRowAsync);\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   * Errors if the function returns more than one row.\n   */\n  async callWithClientZeroOrOneRowAsync(\n    client: pg.PoolClient,\n    functionName: string,\n    params: any[],\n  ): Promise<pg.QueryResult> {\n    debug('callWithClientZeroOrOneRow()', 'function:', functionName);\n    debug('callWithClientZeroOrOneRow()', 'params:', debugParams(params));\n    const result = await this.callWithClientAsync(client, functionName, params);\n    if (result.rowCount == null || result.rowCount > 1) {\n      throw new PostgresError('Incorrect rowCount: ' + result.rowCount, {\n        functionName,\n        sqlParams: params,\n      });\n    }\n    debug('callWithClientZeroOrOneRow() success', 'rowCount:', result.rowCount);\n    return result;\n  }\n\n  /**\n   * Calls a function with the specified parameters using a specific client.\n   * Errors if the function returns more than one row.\n   */\n  callWithClientZeroOrOneRow = callbackify(this.callWithClientZeroOrOneRowAsync);\n\n  /**\n   * Wrapper around {@link queryAsync} that parses the resulting rows with the\n   * given Zod schema. Returns only the rows of the query.\n   */\n  async queryValidatedRows<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>[]> {\n    const results = await this.queryAsync(query, params);\n    return z.array(model).parse(results.rows);\n  }\n\n  /**\n   * Wrapper around {@link queryOneRowAsync} that parses the resulting row with\n   * the given Zod schema. Returns only a single row of the query.\n   */\n  async queryValidatedOneRow<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>> {\n    const results = await this.queryOneRowAsync(query, params);\n    return model.parse(results.rows[0]);\n  }\n\n  /**\n   * Wrapper around {@link queryZeroOrOneRowAsync} that parses the resulting row\n   * (if any) with the given Zod schema. Returns either a single row or `null`.\n   */\n  async queryValidatedZeroOrOneRow<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model> | null> {\n    const results = await this.queryZeroOrOneRowAsync(query, params);\n    if (results.rows.length === 0) {\n      return null;\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  /**\n   * Wrapper around {@link queryAsync} that validates that only one column is\n   * returned and parses the data in it with the given Zod schema. Returns only\n   * the single column of the query as an array.\n   */\n  async queryValidatedSingleColumnRows<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>[]> {\n    const results = await this.queryAsync(query, params);\n    if (results.fields.length !== 1) {\n      throw new Error(`Expected one column, got ${results.fields.length}`);\n    }\n    const columnName = results.fields[0].name;\n    const rawData = results.rows.map((row) => row[columnName]);\n    return z.array(model).parse(rawData);\n  }\n\n  /**\n   * Wrapper around {@link queryOneRowAsync} that validates that only one column\n   * is returned and parses the data in it with the given Zod schema. Returns\n   * only the single entry.\n   */\n  async queryValidatedSingleColumnOneRow<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>> {\n    const results = await this.queryOneRowAsync(query, params);\n    if (results.fields.length !== 1) {\n      throw new Error(`Expected one column, got ${results.fields.length}`);\n    }\n    const columnName = results.fields[0].name;\n    return model.parse(results.rows[0][columnName]);\n  }\n\n  /**\n   * Wrapper around {@link queryZeroOrOneRowAsync} that validates that only one\n   * column is returned and parses the data in it (if any) with the given Zod\n   * schema. Returns either the single row of the query or `null`.\n   */\n  async queryValidatedSingleColumnZeroOrOneRow<Model extends z.ZodTypeAny>(\n    query: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model> | null> {\n    const results = await this.queryZeroOrOneRowAsync(query, params);\n    if (results.fields.length !== 1) {\n      throw new Error(`Expected one column, got ${results.fields.length}`);\n    }\n    if (results.rows.length === 0) {\n      return null;\n    } else {\n      const columnName = results.fields[0].name;\n      return model.parse(results.rows[0][columnName]);\n    }\n  }\n\n  /**\n   * Wrapper around {@link callAsync} that parses the resulting rows with the\n   * given Zod schema. Returns only the rows.\n   */\n  async callValidatedRows<Model extends z.ZodTypeAny>(\n    sprocName: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model>[]> {\n    const results = await this.callAsync(sprocName, params);\n    return z.array(model).parse(results.rows);\n  }\n\n  /**\n   * Wrapper around {@link callOneRowAsync} that parses the resulting rows with\n   * the given Zod schema. Returns only a single row.\n   */\n  async callValidatedOneRow<Model extends z.ZodTypeAny>(\n    sprocName: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model>> {\n    const results = await this.callOneRowAsync(sprocName, params);\n    return model.parse(results.rows[0]);\n  }\n\n  /**\n   * Wrapper around {@link callZeroOrOneRowAsync} that parses the resulting row\n   * (if any) with the given Zod schema. Returns at most a single row.\n   */\n  async callValidatedZeroOrOneRow<Model extends z.ZodTypeAny>(\n    sprocName: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model> | null> {\n    const results = await this.callZeroOrOneRowAsync(sprocName, params);\n    if (results.rows.length === 0) {\n      return null;\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  async queryRows<Model extends z.ZodTypeAny>(sql: string, model: Model): Promise<z.infer<Model>[]>;\n  async queryRows<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>[]>;\n  async queryRows<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: QueryParams | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? {} : (paramsOrSchema as QueryParams);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.queryAsync(sql, params);\n    if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      const rawData = results.rows.map((row) => row[columnName]);\n      return z.array(model).parse(rawData);\n    } else {\n      return z.array(model).parse(results.rows);\n    }\n  }\n\n  async queryRow<Model extends z.ZodTypeAny>(sql: string, model: Model): Promise<z.infer<Model>>;\n  async queryRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model>>;\n  async queryRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: QueryParams | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? {} : (paramsOrSchema as QueryParams);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.queryOneRowAsync(sql, params);\n    if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      return model.parse(results.rows[0][columnName]);\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  async queryOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    model: Model,\n  ): Promise<z.infer<Model> | null>;\n  async queryOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<z.infer<Model> | null>;\n  async queryOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: QueryParams | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? {} : (paramsOrSchema as QueryParams);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.queryZeroOrOneRowAsync(sql, params);\n    if (results.rows.length === 0) {\n      return null;\n    } else if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      return model.parse(results.rows[0][columnName]);\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  async callRows<Model extends z.ZodTypeAny>(sql: string, model: Model): Promise<z.infer<Model>[]>;\n  async callRows<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model>[]>;\n  async callRows<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: any[] | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? [] : (paramsOrSchema as any[]);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.callAsync(sql, params);\n    if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      const rawData = results.rows.map((row) => row[columnName]);\n      return z.array(model).parse(rawData);\n    } else {\n      return z.array(model).parse(results.rows);\n    }\n  }\n\n  async callRow<Model extends z.ZodTypeAny>(sql: string, model: Model): Promise<z.infer<Model>>;\n  async callRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model>>;\n  async callRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: any[] | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? [] : (paramsOrSchema as any[]);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.callOneRowAsync(sql, params);\n    if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      return model.parse(results.rows[0][columnName]);\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  async callOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    model: Model,\n  ): Promise<z.infer<Model> | null>;\n  async callOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: any[],\n    model: Model,\n  ): Promise<z.infer<Model> | null>;\n  async callOptionalRow<Model extends z.ZodTypeAny>(\n    sql: string,\n    paramsOrSchema: any[] | Model,\n    maybeModel?: Model,\n  ) {\n    const params = maybeModel === undefined ? [] : (paramsOrSchema as any[]);\n    const model = maybeModel === undefined ? (paramsOrSchema as Model) : maybeModel;\n    const results = await this.callZeroOrOneRowAsync(sql, params);\n    if (results.rows.length === 0) {\n      return null;\n    } else if (results.fields.length === 1) {\n      const columnName = results.fields[0].name;\n      return model.parse(results.rows[0][columnName]);\n    } else {\n      return model.parse(results.rows[0]);\n    }\n  }\n\n  /**\n   * Returns a {@link Cursor} for the given query. The cursor can be used to\n   * read results in batches, which is useful for large result sets.\n   */\n  async queryCursorWithClient(\n    client: pg.PoolClient,\n    sql: string,\n    params: QueryParams,\n  ): Promise<Cursor> {\n    this._queryCount += 1;\n    debug('queryCursorWithClient()', 'sql:', debugString(sql));\n    debug('queryCursorWithClient()', 'params:', debugParams(params));\n    const { processedSql, paramsArray } = paramsToArray(sql, params, this.errorOnUnusedParameters);\n    lastQueryMap.set(client, processedSql);\n    return client.query(new Cursor(processedSql, paramsArray));\n  }\n\n  /**\n   * Returns an {@link CursorIterator} that can be used to iterate over the\n   * results of the query in batches, which is useful for large result sets.\n   */\n  async queryCursor<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n  ): Promise<CursorIterator<z.infer<Model>>> {\n    return this.queryValidatedCursorInternal(sql, params);\n  }\n\n  /**\n   * Returns an {@link CursorIterator} that can be used to iterate over the\n   * results of the query in batches, which is useful for large result sets.\n   * Each row will be parsed by the given Zod schema.\n   */\n  async queryValidatedCursor<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n    model: Model,\n  ): Promise<CursorIterator<z.infer<Model>>> {\n    return this.queryValidatedCursorInternal(sql, params, model);\n  }\n\n  private async queryValidatedCursorInternal<Model extends z.ZodTypeAny>(\n    sql: string,\n    params: QueryParams,\n    model?: Model,\n  ): Promise<CursorIterator<z.infer<Model>>> {\n    const client = await this.getClientAsync();\n    const cursor = await this.queryCursorWithClient(client, sql, params);\n\n    let iterateCalled = false;\n    const iterator: CursorIterator<z.infer<Model>> = {\n      async *iterate(batchSize: number) {\n        // Safety check: if someone calls iterate multiple times, they're\n        // definitely doing something wrong.\n        if (iterateCalled) {\n          throw new Error('iterate() called multiple times');\n        }\n        iterateCalled = true;\n\n        try {\n          while (true) {\n            const rows = await cursor.read(batchSize);\n            if (rows.length === 0) {\n              break;\n            }\n\n            if (model) {\n              yield z.array(model).parse(rows);\n            } else {\n              yield rows;\n            }\n          }\n        } catch (err: any) {\n          throw enhanceError(err, sql, params);\n        } finally {\n          try {\n            await cursor.close();\n          } finally {\n            client.release();\n          }\n        }\n      },\n      stream(batchSize: number) {\n        const transform = new Transform({\n          readableObjectMode: true,\n          writableObjectMode: true,\n          transform(chunk, _encoding, callback) {\n            for (const row of chunk) {\n              this.push(row);\n            }\n            callback();\n          },\n        });\n\n        // TODO: use native `node:stream#compose` once it's stable.\n        const generator = iterator.iterate(batchSize);\n        const pipe = multipipe(Readable.from(generator), transform);\n\n        // When the underlying stream is closed, we need to make sure that the\n        // cursor is also closed. We do this by calling `return()` on the generator,\n        // which will trigger its `finally` block, which will in turn release\n        // the client and close the cursor. The fact that the stream is already\n        // closed by this point means that someone reading from the stream will\n        // never actually see the `null` value that's returned.\n        pipe.once('close', () => {\n          generator.return(null);\n        });\n\n        return pipe;\n      },\n    };\n    return iterator;\n  }\n\n  /**\n   * Set the schema to use for the search path.\n   *\n   * @param schema The schema name to use (can be \"null\" to unset the search path)\n   */\n  async setSearchSchema(schema: string) {\n    if (schema == null) {\n      this.searchSchema = schema;\n      return;\n    }\n\n    await this.queryAsync(`CREATE SCHEMA IF NOT EXISTS ${escapeIdentifier(schema)}`, {});\n    // We only set searchSchema after CREATE to avoid the above query() call using searchSchema.\n    this.searchSchema = schema;\n  }\n\n  /**\n   * Get the schema that is currently used for the search path.\n   *\n   * @return schema in use (may be `null` to indicate no schema)\n   */\n  getSearchSchema(): string | null {\n    return this.searchSchema;\n  }\n\n  /**\n   * Generate, set, and return a random schema name.\n   *\n   * @param prefix The prefix of the new schema, only the first 28 characters will be used (after lowercasing).\n   * @returns The randomly-generated search schema.\n   */\n  async setRandomSearchSchemaAsync(prefix: string): Promise<string> {\n    // truncated prefix (max 28 characters)\n    const truncPrefix = prefix.substring(0, 28);\n    // timestamp in format YYYY-MM-DDTHH:MM:SS.SSSZ (guaranteed to not exceed 27 characters in the spec)\n    const timestamp = new Date().toISOString();\n    // random 6-character suffix to avoid clashes (approx 2 billion possible values)\n    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n    const suffix = Array.from({ length: 6 })\n      .map(() => chars[Math.floor(Math.random() * chars.length)])\n      .join('');\n\n    // Schema is guaranteed to have length at most 63 (= 28 + 1 + 27 + 1 + 6),\n    // which is the default PostgreSQL identifier limit.\n    // Note that this schema name will need quoting because of characters like ':', '-', etc\n    const schema = `${truncPrefix}_${timestamp}_${suffix}`;\n    await this.setSearchSchema(schema);\n    return schema;\n  }\n\n  /**\n   * Generate, set, and return a random schema name.\n   */\n  setRandomSearchSchema = callbackify(this.setRandomSearchSchemaAsync);\n\n  /** The number of established connections. */\n  get totalCount() {\n    return this.pool?.totalCount ?? 0;\n  }\n\n  /** The number of idle connections. */\n  get idleCount() {\n    return this.pool?.idleCount ?? 0;\n  }\n\n  /** The number of queries waiting for a connection to become available. */\n  get waitingCount() {\n    return this.pool?.waitingCount ?? 0;\n  }\n\n  /** The total number of queries that have been executed by this pool. */\n  get queryCount() {\n    return this._queryCount;\n  }\n}\n"]}