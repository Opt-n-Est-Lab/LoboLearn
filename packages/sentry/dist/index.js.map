{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,wBAAwB,EAAE,wBAAwB,EAAE,MAAM,cAAc,CAAC;AAClF,OAAO,KAAK,MAAM,MAAM,cAAc,CAAC;AACvC,OAAO,EAAE,KAAK,EAAE,MAAM,OAAO,CAAC;AAE9B;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,IAAI,CAAC,OAA2B;IACpD,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAE9B,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,IAAI,CAAC;YACH,OAAO,GAAG,CAAC,MAAM,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;QACtE,CAAC;QAAC,MAAM,CAAC;YACP,mEAAmE;YACnE,oCAAoC;QACtC,CAAC;IACH,CAAC;IAED,MAAM,CAAC,IAAI,CAAC;QACV,OAAO;QACP,GAAG,OAAO;KACX,CAAC,CAAC;AACL,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CAAC,GAAQ;IAClC,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC;IAC/C,MAAM,IAAI,GAAG,wBAAwB,CAAC,GAAG,CAAC,WAAW,IAAI,GAAG,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;IAExE,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,IAAI,MAAM,EAAE,CAAC;QACX,IAAI,IAAI,MAAM,CAAC;IACjB,CAAC;IACD,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;QACnB,IAAI,IAAI,GAAG,CAAC;IACd,CAAC;IACD,IAAI,IAAI,EAAE,CAAC;QACT,IAAI,IAAI,IAAI,CAAC;IACf,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,cAAc;IAC5B,OAAO,CAAC,GAAQ,EAAE,IAAS,EAAE,IAAS,EAAE,EAAE;QACxC,MAAM,CAAC,kBAAkB,CAAC,CAAC,KAAK,EAAE,EAAE;YAClC,KAAK,CAAC,iBAAiB,CAAC,CAAC,KAAK,EAAE,EAAE;gBAChC,kEAAkE;gBAClE,kEAAkE;gBAClE,oEAAoE;gBACpE,sBAAsB;gBACtB,IAAI,CAAC;oBACH,KAAK,CAAC,WAAW,GAAG,kBAAkB,CAAC,GAAG,CAAC,CAAC;oBAC5C,KAAK,CAAC,OAAO,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC;oBAC9C,OAAO,KAAK,CAAC;gBACf,CAAC;gBAAC,MAAM,CAAC;oBACP,OAAO,KAAK,CAAC;gBACf,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,IAAI,EAAE,CAAC;QACT,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAuBD,OAAO,EACL,aAAa,EACb,iBAAiB,EACjB,YAAY,EACZ,gBAAgB,EAChB,cAAc,EACd,KAAK,EACL,eAAe,EACf,kBAAkB,EAClB,mBAAmB,EACnB,kBAAkB,EAClB,KAAK,EACL,eAAe,EACf,gBAAgB,EAChB,iBAAiB,EACjB,UAAU,EACV,KAAK,EACL,WAAW,EACX,oBAAoB,EACpB,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,wBAAwB,EACxB,OAAO,EACP,iBAAiB,EACjB,SAAS,EACT,eAAe,EACf,kBAAkB,EAClB,SAAS,GACV,MAAM,cAAc,CAAC","sourcesContent":["import { httpRequestToRequestData, stripUrlQueryAndFragment } from '@sentry/core';\nimport * as Sentry from '@sentry/node';\nimport { execa } from 'execa';\n\n/**\n * A thin wrapper around {@link Sentry.init} that automatically sets `release`\n * based on the current Git revision.\n */\nexport async function init(options: Sentry.NodeOptions) {\n  let release = options.release;\n\n  if (!release) {\n    try {\n      release = (await execa('git', ['rev-parse', 'HEAD'])).stdout.trim();\n    } catch {\n      // This most likely isn't running in an initialized git repository.\n      // Default to not setting a release.\n    }\n  }\n\n  Sentry.init({\n    release,\n    ...options,\n  });\n}\n\n/**\n * Based on Sentry code that is not exported:\n * https://github.com/getsentry/sentry-javascript/blob/602703652959b581304a7849cb97117f296493bc/packages/utils/src/requestdata.ts#L102\n */\nfunction extractTransaction(req: any) {\n  const method = req.method?.toUpperCase() || '';\n  const path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n\n  let name = '';\n  if (method) {\n    name += method;\n  }\n  if (method && path) {\n    name += ' ';\n  }\n  if (path) {\n    name += path;\n  }\n\n  return name;\n}\n\n/**\n * Sentry v8 switched from simple, manual instrumentation to \"automatic\"\n * instrumentation based on OpenTelemetry. However, this interferes with\n * the way that our applications asynchronously load their configuration,\n * specifically the Sentry DSN. Sentry's automatic request isolation and\n * request data extraction requires that `Sentry.init` be called before\n * any other code is loaded, but our application startup structure is such\n * that we import most of our own code before we can load the Sentry DSN.\n *\n * Rather than jumping through hoops to restructure our application to\n * support this, this small function can be added as Express middleware to\n * isolate requests and set request data for Sentry.\n */\nexport function requestHandler() {\n  return (req: any, _res: any, next: any) => {\n    Sentry.withIsolationScope((scope) => {\n      scope.addEventProcessor((event) => {\n        // If an event processor throws an error, Sentry will catch it and\n        // retrigger the event processor, which infinitely recurses. We'll\n        // treat our event processor as a best-effort operation and silently\n        // swallow any errors.\n        try {\n          event.transaction = extractTransaction(req);\n          event.request = httpRequestToRequestData(req);\n          return event;\n        } catch {\n          return event;\n        }\n      });\n\n      next();\n    });\n  };\n}\n\n// We export every type and function from `@sentry/node` *except* for init,\n// which we replace with our own version up above.\n\nexport type {\n  Breadcrumb,\n  BreadcrumbHint,\n  Event,\n  EventHint,\n  Exception,\n  NodeOptions,\n  PolymorphicRequest,\n  SdkInfo,\n  Session,\n  SeverityLevel,\n  Span,\n  StackFrame,\n  Stacktrace,\n  Thread,\n  User,\n} from '@sentry/node';\n\nexport {\n  addBreadcrumb,\n  addEventProcessor,\n  captureEvent,\n  captureException,\n  captureMessage,\n  close,\n  createTransport,\n  defaultStackParser,\n  expressErrorHandler,\n  expressIntegration,\n  flush,\n  getCurrentScope,\n  getSentryRelease,\n  makeNodeTransport,\n  NodeClient,\n  Scope,\n  SDK_VERSION,\n  SentryContextManager,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setupExpressErrorHandler,\n  setUser,\n  startInactiveSpan,\n  startSpan,\n  startSpanManual,\n  withIsolationScope,\n  withScope,\n} from '@sentry/node';\n"]}