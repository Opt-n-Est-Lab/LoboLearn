{"version":3,"file":"session.js","sourceRoot":"","sources":["../src/session.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'node:crypto';\n\nimport type { Request } from 'express';\nimport uid from 'uid-safe';\n\nimport { type SessionStore } from './store.js';\n\nexport interface Session {\n  id: string;\n  destroy(): Promise<void>;\n  regenerate(): Promise<void>;\n  setExpiration(expiry: Date | number): void;\n  getExpirationDate(): Date;\n  [key: string]: any;\n}\n\nexport async function generateSessionId(): Promise<string> {\n  return await uid(24);\n}\n\nexport async function loadSession(\n  sessionId: string,\n  req: Request,\n  store: SessionStore,\n  maxAge: number,\n): Promise<Session> {\n  const sessionStoreData = await store.get(sessionId);\n  const expiresAt = sessionStoreData?.expiresAt ?? null;\n\n  const session = makeSession(sessionId, req, store, expiresAt, maxAge);\n\n  if (sessionStoreData == null) {\n    // Immediately persis the new session to the store so that it's assigned\n    // an ID and available to query later on in the same request.\n    await store.set(\n      sessionId,\n      session,\n      // Cookies only support second-level resolution. To ensure consistency\n      // between the cookie and the store, truncate the expiration date to\n      // the nearest second.\n      truncateExpirationDate(session.getExpirationDate()),\n    );\n  }\n\n  // Copy session data into the session object.\n  if (sessionStoreData != null) {\n    const { data } = sessionStoreData;\n    for (const prop in data) {\n      if (!(prop in session)) {\n        session[prop] = data[prop];\n      }\n    }\n  }\n\n  return session;\n}\n\nexport function makeSession(\n  sessionId: string,\n  req: Request,\n  store: SessionStore,\n  expirationDate: Date | null,\n  maxAge: number,\n): Session {\n  const session = {};\n\n  let expiresAt = expirationDate;\n\n  defineStaticProperty<Session['id']>(session, 'id', sessionId);\n\n  defineStaticProperty<Session['destroy']>(session, 'destroy', async () => {\n    delete (req as any).session;\n    await store.destroy(sessionId);\n  });\n\n  defineStaticProperty<Session['regenerate']>(session, 'regenerate', async () => {\n    await store.destroy(sessionId);\n    req.session = makeSession(await generateSessionId(), req, store, null, maxAge);\n  });\n\n  defineStaticProperty<Session['getExpirationDate']>(session, 'getExpirationDate', () => {\n    if (expiresAt == null) {\n      expiresAt = new Date(Date.now() + maxAge);\n    }\n    return expiresAt;\n  });\n\n  defineStaticProperty<Session['setExpiration']>(session, 'setExpiration', (expiration) => {\n    if (typeof expiration === 'number') {\n      expiresAt = new Date(Date.now() + expiration);\n    } else {\n      expiresAt = expiration;\n    }\n  });\n\n  return session as Session;\n}\n\nexport function hashSession(session: Session): string {\n  const str = JSON.stringify(session);\n  return crypto.createHash('sha1').update(str, 'utf8').digest('hex');\n}\n\nfunction defineStaticProperty<T>(obj: object, name: string, fn: T) {\n  Object.defineProperty(obj, name, {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: fn,\n  });\n}\n\nexport function truncateExpirationDate(date: Date) {\n  const time = date.getTime();\n  const truncatedTime = Math.floor(time / 1000) * 1000;\n  return new Date(truncatedTime);\n}\n"]}