{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import parsePostgresInterval from 'postgres-interval';\nimport { z } from 'zod';\n\nconst INTERVAL_MS_PER_SECOND = 1000;\nconst INTERVAL_MS_PER_MINUTE = 60 * INTERVAL_MS_PER_SECOND;\nconst INTERVAL_MS_PER_HOUR = 60 * INTERVAL_MS_PER_MINUTE;\nconst INTERVAL_MS_PER_DAY = 24 * INTERVAL_MS_PER_HOUR;\nconst INTERVAL_MS_PER_MONTH = 30 * INTERVAL_MS_PER_DAY;\nconst INTERVAL_MS_PER_YEAR = 365.25 * INTERVAL_MS_PER_DAY;\n\n/**\n * A Zod schema for a boolean from a single checkbox input in the body\n * parameters from a form. This will return a boolean with a value of `true` if\n * the checkbox is checked (the input is present) and `false` if it is not\n * checked.\n */\nexport const BooleanFromCheckboxSchema = z\n  .string()\n  .optional()\n  .transform((s) => !!s);\n\n/**\n * A Zod schema for a PostgreSQL ID.\n *\n * We store IDs as BIGINT in PostgreSQL, which are passed to JavaScript as\n * either strings (if the ID is fetched directly) or numbers (if passed via\n * `to_jsonb()`). This schema coerces the ID to a string to ensure consistent\n * handling.\n *\n * The `refine` step is important to ensure that the thing we've coerced to a\n * string is actually a number. If it's not, we want to fail quickly.\n */\nexport const IdSchema = z\n  .string({ coerce: true })\n  .refine((val) => /^\\d+$/.test(val), { message: 'ID is not a non-negative integer' });\n\n/**\n * A Zod schema for the objects produced by the `postgres-interval` library.\n */\nconst PostgresIntervalSchema = z.object({\n  years: z.number().default(0),\n  months: z.number().default(0),\n  days: z.number().default(0),\n  hours: z.number().default(0),\n  minutes: z.number().default(0),\n  seconds: z.number().default(0),\n  milliseconds: z.number().default(0),\n});\n\n/**\n * A Zod schema for a PostgreSQL interval.\n *\n * This handles two representations of an interval:\n *\n * - A string like \"1 year 2 days\", which is how intervals will be represented\n *   if they go through `to_jsonb` in a query.\n * - A {@link PostgresIntervalSchema} object, which is what we'll get if a\n *   query directly returns an interval column. The interval will already be\n *   parsed by `postgres-interval` by way of `pg-types`.\n *\n * In either case, we convert the interval to a number of milliseconds.\n */\nexport const IntervalSchema = z\n  .union([z.string(), PostgresIntervalSchema])\n  .transform((interval) => {\n    if (typeof interval === 'string') {\n      interval = parsePostgresInterval(interval);\n    }\n\n    // This calculation matches Postgres's behavior when computing the number of\n    // milliseconds in an interval with `EXTRACT(epoch from '...'::interval) * 1000`.\n    // The noteworthy parts of this conversion are that 1 year = 365.25 days and\n    // 1 month = 30 days.\n    return (\n      interval.years * INTERVAL_MS_PER_YEAR +\n      interval.months * INTERVAL_MS_PER_MONTH +\n      interval.days * INTERVAL_MS_PER_DAY +\n      interval.hours * INTERVAL_MS_PER_HOUR +\n      interval.minutes * INTERVAL_MS_PER_MINUTE +\n      interval.seconds * INTERVAL_MS_PER_SECOND +\n      interval.milliseconds\n    );\n  });\n\n/**\n * A Zod schema for a date string in ISO format.\n *\n * Accepts either a string or a Date object. If a string is passed, it is\n * validated and parsed as an ISO date string.\n *\n * Useful for parsing dates from JSON, which are always strings.\n */\nexport const DateFromISOString = z\n  .union([z.string(), z.date()])\n  .refine(\n    (s) => {\n      const date = new Date(s);\n      return !Number.isNaN(date.getTime());\n    },\n    {\n      message: 'must be a valid ISO date string',\n    },\n  )\n  .transform((s) => new Date(s));\n"]}